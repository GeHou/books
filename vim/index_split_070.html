<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Vim实用技巧</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos345606" class="calibre_8"><span class="calibre1"><span class="bold">技巧60深入理解Vim寄存器</span></span></p><p class="calibre_9"> Vim不使用单一的剪贴板进行剪切、复制与粘贴操作，而是为这些操作提供了多组寄存器。当使用删除、复制与粘贴命令时，我们可以明确指定它们中的某一个进行操作。 </p><p class="calibre_8"><span class="calibre3"><span class="bold">引用一个寄存器</span></span></p><p class="calibre_9">Vim的删除、复制与粘贴命令都会用到众多寄存器中的某一个。我们可以通过给命令加<span class="bold">"{register}</span>前缀的方式指定要用的寄存器。若不指明，Vim将缺省使用无名寄存器。</p><p class="calibre_5">
<a class="calibre2"></a>
</p><p class="calibre_6">Vim术语对照表</p><p class="calibre_6"> 剪切（cut）、复制（copy）与粘贴（paste），这些都是众所周知的术语，而且大多数桌面软件和操作系统都支持这3类操作。Vim当然也提供这些功能，只不过使用的是另外的术语delete、yank与put<sup class="calibre5"><small id="filepos346776" class="calibre6"><a href="index_split_073.html#filepos376509" class="calibre2"><span class="calibre7"><span class="calibre_2"><span class="underline">(1)</span></span></span></a></small></sup>。 </p><p class="calibre_7"> Vim的put命令与粘贴操作完全相同。幸运的是，两词均以字母p开头，因此即使术语不同，也不会影响记忆。 </p><p class="calibre_7"> Vim的yank命令也等同于复制操作。但由于历史原因，当时c命令已经被用于修改（change）操作了，因此Vi的作者们被迫选择了另一个名字yank。由于那时y键还可用，因此它就成了复制操作的命令。 </p><p class="calibre_7"> Vim的delete命令也与标准剪切操作的作用一致。也就是说，该命令会先把指定文本复制到寄存器后再从文档中删掉。能够理解这一点，是避开类似<span class="italic">糟糕！我弄丢了复制内容</span>所遇到的常见陷阱的关键。 </p><p class="calibre_7"> 你也许好奇，Vim中真正删除文本的操作是什么。也就是说，我们怎样才能删除文本而不把其内容复制到任何寄存器？答案是使用名为“黑洞”的特殊寄存器，顾名思义，放到这里的文本真地是有去无回了。用下划线符号（参见:h quote_<img src="images/00243.jpg" class="calibre_10"/>）可以引用黑洞寄存器。因此，"_d{motion}会执行真正的删除操作。 </p><p class="calibre_7">让我们看一些引用寄存器的例子，如果我们想把当前单词复制到寄存器<span class="bold">a</span>中，可执行 <span class="bold">"ayiw</span>，或者，可以用 <span class="bold">"bdd</span>，把当前整行文本剪切至寄存器<span class="bold">b</span>中。在此之后，我们既可以输入 <span class="bold">"ap</span>粘贴来自寄存器<span class="bold">a</span>的单词，也可使用 <span class="bold">"bp</span>命令粘贴来自寄存器<span class="bold">b</span>的一整行文本，两者互不干扰。</p><p class="calibre_7">除了普通模式的命令外，Vim也提供用于删除、复制与粘贴操作的Ex命令。例如，我们可以执行 <span class="bold">:delete c</span>，把当前行剪切到寄存器 <span class="bold">c</span>，然后再执行 <span class="bold">:put c</span>命令将其粘贴至当前光标所在行之下。相比普通模式的命令而言，这些操作看似繁琐，但如果将它们与其他Ex命令结合起来使用，或者用于Vim脚本编程，将会更方便。例如，技巧99就为我们展示了 <span class="bold">:yank</span> 命令怎样和 <span class="bold">:global</span> 命令一起使用的场景。</p><p class="calibre_5">
<a class="calibre2"></a>
</p><p class="calibre_8"><span class="calibre3"><span class="bold">无名寄存器（""）</span></span></p><p class="calibre_9">倘若我们没有指定要使用的寄存器，Vim将缺省使用无名寄存器，它可以用双引号表示（参见<span class="bold">:h quote_quote</span><img src="images/00243.jpg" class="calibre_10"/>）。为了显式地引用该寄存器，我们得使用两个双引号。例如，<span class="bold">""p</span>，它完全等同于<span class="bold">p</span>命令。</p><p class="calibre_7"><span class="bold">x</span>、<span class="bold">s</span>、<span class="bold">d{motion}</span>、<span class="bold">c{motion}</span>与<span class="bold">y{motion}</span>命令（以及它们对应的大写命令）都会覆盖无名寄存器中的内容。无论哪一种情况，都可以通过加<span class="bold">"{register}</span>前缀来指定另外一个寄存器，但无名寄存器总是缺省的。事实上，无名寄存器的内容很容易被覆盖，如果我们不小心的话，会导致问题发生。</p><p class="calibre_7">请再回想一下糟糕！我弄丢了复制内容中的例子。一开始，我们复制了文本（单词“collection”）并打算粘贴到其他地方，在粘贴之前，我们在选好的位置删除了一些文本，旨在清理出一块空白区域，而正是这一操作导致了无名寄存器的内容被覆盖。当我们再次使用<span class="bold">p</span>命令时，粘贴的是刚刚删除的文本，而不是之前复制的文本。</p><p class="calibre_7">在这一点上，Vim术语的命名确实有问题。<span class="bold">x</span>和<span class="bold">d{motion}</span>经常被当作“删除”命令。这其实是用词不当，把它们理解为“剪切”命令会更合适。无名寄存器中经常找不到我想要的文本，不过幸运的是，复制专用寄存器（我们将在下一节中遇到）要更可靠些。</p><p class="calibre_8"><span class="calibre3"><span class="bold">复制专用寄存器（"0）</span></span></p><p class="calibre_9">当我们使用<span class="bold">y{motion}</span> 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，后者可用数字0（参见 <span class="bold">:h quote</span>0<img src="images/00243.jpg" class="calibre_10"/>）加以引用。</p><p class="calibre_7">复制专用寄存器，顾名思义，仅当使用<span class="bold">y{motion}</span>命令时才会被赋值。换句话讲，使用<span class="bold">x</span>、<span class="bold">s</span>、<span class="bold">c{motion}</span>以及<span class="bold">d{motion}</span>命令均不会覆盖该寄存器。如果我们复制了一些文本，可以确信该文本会一直保存于寄存器0中，直到我们复制其他文本时才会被覆盖。复制专用寄存器是稳定的，而无名寄存器是易变的。</p><p class="calibre_7">我们可以用复制专用寄存器解决糟糕！我弄丢了复制内容中的问题。</p><p class="calibre_6"><img src="images/00119.jpg" class="calibre_158"/></p><p class="calibre_6">尽管<span class="bold">diw</span> 命令仍会覆盖无名寄存器，但不会波及复制专用寄存器。我们可以通过输入 <span class="bold">"0P</span>，安全地粘贴来自复制专用寄存器中的内容。这一次Vim终于给出了我们想要的文本。</p><p class="calibre_7">如果我们此时检查无名寄存器和复制专用寄存器的内容，会发现它们分别保存着刚刚被删除与复制的文本：</p><p class="calibre_8"><span class="bold">➾:reg "0</span></p><p class="calibre_8"><span class="calibre8"> 《 --- Registers ---</span><br class="calibre4"/><span class="calibre8"> "" somethingInTheWay</span><br class="calibre4"/><span class="calibre8"> "0 collection </span></p><p class="calibre_8"><span class="calibre3"><span class="bold">有名寄存器（"a – "z）</span></span></p><p class="calibre_9">Vim提供了一组以26个英文字母（参见 <span class="bold">:h quote_alpha</span><img src="images/00243.jpg" class="calibre_10"/>）命名的有名寄存器。这意味着我们可以剪切（ <span class="bold">"ad{motion}</span>）、复制（<span class="bold">"ay{motion}</span>）或者粘贴（<span class="bold">"ap</span>）多达26段文本。</p><p class="calibre_7">可以用有名寄存器解决糟糕！我弄丢了复制内容中的问题。</p><p class="calibre_6"><img src="images/00176.jpg" class="calibre_159"/></p><p class="calibre_6">使用有名寄存器需要额外的按键操作，因此对于类似本例的简单问题，最好使用复制专用寄存器（"0）。如果碰到需要将一段或多段文本粘贴到多处的情况，有名寄存器就会大显神通。</p><p class="calibre_7">用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后。请跳到技巧99，那里展示了一个如何向寄存器附加内容的实例。</p><p class="calibre_8"><span class="calibre3"><span class="bold">黑洞寄存器</span></span></p><p class="calibre_9">黑洞寄存器是个有去无回的地方，可用下划线（参见 <span class="bold">:h quote_</span><img src="images/00243.jpg" class="calibre_10"/>）引用它。如果我们运行 <span class="bold">"_d{motion}</span> 命令，Vim将删除该文本且不保存任何副本。当我们只想<a class="calibre2"></a>删除文本却不想覆盖无名寄存器中的内容时，此命令很管用。</p><p class="calibre_7">可以用黑洞寄存器解决糟糕！我弄丢了复制内容中的问题。</p><p class="calibre_6"><img src="images/00194.jpg" class="calibre_160"/></p><p class="calibre_8"><span class="calibre3"><span class="bold">系统剪贴板（"+）与选择专用寄存器（"*）</span></span></p><p class="calibre_9">到目前为止，我们所讨论的寄存器都是Vim内部的。如果想从Vim复制文本到外部程序（反之亦然），则必须使用系统剪贴板。</p><p class="calibre_7">Vim的加号寄存器与系统剪贴板等效，可用 + 号（参见 <span class="bold">:h quote+</span><img src="images/00243.jpg" class="calibre_10"/>）引用。</p><p class="calibre_7">如果我们在外部程序中用剪切或复制命令获取了文本，就可以通过 <span class="bold">"+p</span> 命令（或在插入模式下用 <span class="bold">&lt;C-r&gt;+</span>）将其粘贴到Vim内部。相反地，如果在Vim的复制或删除命令之前加入 <span class="bold">"+</span> ，相应的文本将被捕获至系统剪贴板。这意味着我们能够轻松地把文本粘贴到其他应用程序中了。</p><p class="calibre_7">X11视窗系统支持另一种被叫作主剪贴板（primary）的剪贴板，它保存着上次被高亮选中的文本，可以用鼠标中键（如果有的话）把它们粘贴出来。Vim的星号寄存器对应主剪贴板，可用 * 号（参见<span class="bold">:h quotestar</span><img src="images/00243.jpg" class="calibre_10"/>）加以引用。</p><p class="calibre4" style="margin:0pt; border:0pt; height:1em"> </p><table valign="top" class="calibre_18"><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20"><span class="bold">  寄存器  </span>
</td><td colspan="1" rowspan="1" valign="top" class="calibre_20"><span class="bold">  用途  </span>
</td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  "+   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  X11剪贴板，用剪切、复制与粘贴命令操作   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  "*   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  X11主剪贴板，用鼠标中键操作   </td></tr></table><p class="calibre_6">Windows与Mac OS X操作系统并没有主剪贴板的概念，因此 "+ 寄存器与 "* 寄存器可以混用，它们都代表系统剪贴板。</p><p class="calibre_7">X11剪贴板的功能可在编译Vim时被激活或禁用。如果想验证该功能是否在自己的Vim中被激活，可运行<span class="bold">:version</span> 命令，然后找到<span class="bold">xterm_clipboard</span>关键字。如果它前面有个减号，就表示你这个版本的Vim不支持该功能，而加号则表示此功能已被激活。</p><p class="calibre_5">
<a class="calibre2"></a>
</p><p class="calibre_8"><span class="calibre3"><span class="bold">表达式寄存器（"=）</span></span></p><p class="calibre_9">Vim的寄存器通常被认为是保存一段文本的容器。然而，通过=号（参见<span class="bold">:h quote=</span><img src="images/00243.jpg" class="calibre_10"/>）引用的表达式寄存器却是个例外。当我们从表达式寄存器获取内容时，Vim将跳到命令行模式，并显示提示符“=”。这时，我们可以输入一段Vim脚本表达式并按<span class="bold">&lt;CR&gt;</span>执行，如果返回的是字符串（或者可被强制转换成字符串的数据），Vim将会使用它。</p><p class="calibre_7">有关表达式寄存器的用法，请参考技巧16、95、94以及70。</p><p class="calibre_8"><span class="calibre3"><span class="bold">其他寄存器</span></span></p><p class="calibre_9">我们可以显式地使用删除与复制命令，来设置有名、无名以及复制专用寄存器的内容。另外，Vim还提供了几组可被隐式赋值的寄存器。它们被称作只读寄存器（参见<span class="bold">:h quote.</span><img src="images/00243.jpg" class="calibre_10"/>），如下表所示：</p><p class="calibre4" style="margin:0pt; border:0pt; height:1em"> </p><table valign="top" class="calibre_18"><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20"><span class="bold">  寄存器  </span>
</td><td colspan="1" rowspan="1" valign="top" class="calibre_20"><span class="bold">  内容  </span>
</td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  "%   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  当前文件名   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  "#   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  轮换文件名   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  ".   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  上次插入的文本   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  ":   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  上次执行的Ex命令   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  "/   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  上次查找的模式   </td></tr></table><p class="calibre_6">“技术上讲，”/ 寄存器并非只读，可以用 :let命令（参见 <span class="bold">:h quote/</span><img src="images/00243.jpg" class="calibre_10"/>）对其进行显式的赋值。但为了方便起见，我们仍把它列入该表。</p><div class="mbp_pagebreak" id="calibre_pb_80"></div>
</body></html>
