<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Vim实用技巧</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos180820" class="calibre_8"><span class="calibre1"><span class="bold">技巧35运行Shell命令</span></span></p><p class="calibre_9"> 我们不用离开 Vim就能方便地调用外部程序。更棒的是，我们还可以把缓冲区的内容作为标准输入发送给一个外部命令，或是把外部命令的标准输出导入到缓冲区里。 </p><p class="calibre_7">本节讨论的命令在终端 Vim 中工作得最好。如果你在运行 GVim（或 MacVim），那么命令运行得也许没那么顺畅。这没什么好奇怪的，如果 Vim 自身在 shell 里运行，那把工作委派给 shell 也会容易得多。GVim 在某些其他方面做得更好一些，但是终端 Vim在这件事上则更有优势。</p><p class="calibre_8"><span class="calibre2"><span class="bold">执行 Shell 中的程序</span></span></p><p class="calibre_9">在 Vim 的命令行模式中，给命令加一个叹号前缀（参见<span class="bold">:h :!</span><img src="images/00243.jpg" class="calibre_10"/>）就可以调用外部程序。例如，如果想查看当前目录的内容，可以运行下面的命令：</p><p class="calibre_8"><span class="bold">➾:!ls</span></p><p class="calibre_8"><span class="calibre6"> 《 duplicate.todo loop.js</span><br class="calibre3"/><span class="calibre6"> emails.csv practical-vim.html</span><br class="calibre3"/><span class="calibre6"> foobar.js shopping-list.todo</span><br class="calibre3"/><span class="calibre6"> history-scrollers.vim</span><br class="calibre3"/><span class="calibre6"> Press ENTER or type command to continue </span></p><p class="calibre_7">注意区分<span class="bold">:!ls</span>和<span class="bold">:ls</span>的不同之处。前者调用的是 shell 中的<span class="bold">l</span>s命令，而<span class="bold">:ls</span>调用的是 Vim的内置命令，用来显示缓冲区列表的内容。</p><p class="calibre_7">在 Vim 的命令行中，符号<span class="bold">%</span>代表当前文件名（参见<span class="bold">:h cmdline-special</span> ）。在运行那些操作当前文件的外部命令时，我们可以使用它。例如，如果我们正在编辑某个Ruby文件，那么可以用下面的方式执行此文件：</p><p class="calibre_8"><span class="bold">➾:!ruby %</span></p><p class="calibre_9">Vim 也提供了一组文件名修饰符，让我们可以从当前文件名中提取出诸如文件路径或扩展名之类的信息（参见<span class="bold">:h filename-modifiers</span><img src="images/00243.jpg" class="calibre_10"/>），技巧44中有一个使用这些修饰符的例子。</p><p class="calibre_7"><span class="bold">:!{cmd}</span>这种语法适用于执行一次性命令，但是如果想在 shell 中执行几条命令要怎么做？对这种情况，可以执行 Vim 的<span class="bold">:shell</span>命令来启动一个交互的 shell 会话（参见<span class="bold">:h :shell</span><img src="images/00243.jpg" class="calibre_10"/>）：</p><p class="calibre_5">
<a></a>
</p><p class="calibre_8"><span class="bold">➾:shell </span></p><p class="calibre_8"><span class="bold">➾$ pwd</span></p><p class="calibre_8"><span class="calibre6"> 《 /Users/drew/books/PracticalVim/code/ex_mode </span></p><p class="calibre_8"><span class="bold">➾$ ls</span></p><p class="calibre_8"><span class="calibre6"> 《 duplicate.todo loop.js</span><br class="calibre3"/><span class="calibre6"> emails.csv practical-vim.html</span><br class="calibre3"/><span class="calibre6"> foobar.js shopping-list.todo</span><br class="calibre3"/><span class="calibre6"> history-scrollers.vim </span></p><p class="calibre_8"><span class="bold">➾$ exit</span></p><p class="calibre_9">用<span class="bold">exit</span>命令可以退出此 shell 并返回 Vim。</p><p class="calibre_6">把Vim置于后台</p><p class="calibre_6"> :shell命令是 Vim 提供的一个功能，它可以让我们切换到一个交互 shell中。但是，如果Vim自身是在终端中运行的话，那么我们也能直接访问终端内置的 shell 命令。例如，bash shell支持作业控制，让我们可以暂停一个作业，把它放到后台，然后在稍后某个时间再把它调回前台继续运行。 </p><p class="calibre_7"> 假设我们正在 bash shell 中运行 Vim，然后需要执行一些 shell 命令。我们可以先按Ctrl-z挂起Vim 所属的进程，并把控制权交还给bash。此时 Vim 进程在后台处于挂起状态，让我们可以像往常一样与 bash 会话进行交互。运行下面这条命令可以查看当前的作业列表： </p><p class="calibre_8"><span class="bold">➾ $ jobs</span></p><p class="calibre_9"> 《 [1]+ Stopped vim </p><p class="calibre_7"> 在 bash 中，我们可以用fg命令唤醒一个被挂起的作业，把它移到前台。这会让 Vim恢复成挂起前的状态。Ctrl-z和fg命令比 Vim 所提供的:shell和exit命令更加方便快捷。要想了解更多信息，请运行man bash，然后阅读作业控制（job control）一节。 </p><p class="calibre_8"><span class="calibre2"><span class="bold">把缓冲区内容作为标准输入或输出</span></span></p><p class="calibre_9">在用<span class="bold">:!{cmd}</span>时，Vim 会回显<span class="bold">{cmd}</span>命令的输出。如果命令的输出很少或没有<a></a>输出，这工作得很好；但如果命令会产生大量输出，这样回显用处不大。另外一种做法是我们可以用<span class="bold">:read !{cmd}</span>命令，把<span class="bold">{cmd}</span>命令的输出读入当前缓冲区中（参见<span class="bold">:h read!</span><img src="images/00243.jpg" class="calibre_10"/>）。</p><p class="calibre_7"><span class="bold">:read !{cmd}</span>命令让我们把命令的标准输出重定向到缓冲区。正如你所期望的一样，<span class="bold">:write !{cmd}</span>做相反的事。它把缓冲区内容作为指定<span class="bold">{cmd}</span>的标准输入（参见<span class="bold">:h :write_c</span><img src="images/00243.jpg" class="calibre_10"/>），跳到技巧45可以看到此功能的一个应用实例。</p><p class="calibre_7">根据叹号在命令行上的位置不同，它的含义也不大相同。比较一下这些命令：</p><p class="calibre_8"><span class="bold">➾:write !sh </span></p><p class="calibre_8"><span class="bold">➾:write ! sh </span></p><p class="calibre_8"><span class="bold">➾:write! sh</span></p><p class="calibre_9">前两个命令都会把缓冲区的内容传给外部的<span class="bold">sh</span>命令作为标准输入，而最后一条命令则调用<span class="bold">:write!</span>命令把缓冲区内容写到一个名为<span class="bold">sh</span>的文件，这里的叹号会让Vim 覆盖任何已存的<span class="bold">sh</span>文件。正如你看到的那样，叹号放得位置不同，命令的作用也大相径庭。因此，在构建这类命令时要多加小心。</p><p class="calibre_7"><span class="bold">:write !sh</span>命令的作用是在shell中执行当前缓冲区中的每行内容，查阅<span class="bold">:h rename-files</span><img src="images/00243.jpg" class="calibre_10"/>可看到该命令的一个绝佳示例。</p><p class="calibre_8"><span class="calibre2"><span class="bold">使用外部命令过滤缓冲区内容</span></span></p><p class="calibre_9">当给定一个范围时，<span class="bold">:!{cmd}</span>命令就具有了不同的含义。由<span class="bold">[range</span>]所指定的行会传给<span class="bold">{cmd}</span>作为标准输入，然后又会用<span class="bold">{cmd}</span>的输出覆盖<span class="bold">[range]</span>内原本的内容。换一种说法就是<span class="bold">[range]</span>内的文本会被指定的<span class="bold">{cmd}</span>进行过滤（参见<span class="bold">:h :range!</span><img src="images/00243.jpg" class="calibre_10"/>）。Vim 把过滤器定义为“一个由标准输入读取文本，并对其进行某种形式的修改后输出到标准输出的程序”。</p><p class="calibre_7">作为演示，我们将用外部的<span class="bold">sort</span>命令对下列 CSV 文件中的记录进行排序：</p><p class="calibre_"><img src="images/00112.jpg" class="calibre_88"/></p><p class="calibre_7">我们想基于第二个字段“姓氏”来重排这些记录。我们可以用<span class="bold">-t’,’</span>参数告诉<span class="bold">sort</span>命令，这些记录以逗号分隔，然后再用<span class="bold">-k2</span>参数指定按第二个字段进行排序。</p><p class="calibre_7">因为文件的第一行是标题信息，我们想把它们保留在文件顶部，因此需要用范围<span class="bold">:2,$</span>把它排除在排序范围之外。下列命令将完成我们想要的功能：</p><p class="calibre_8"><span class="bold">➾:2,$!sort -t',' -k2</span></p><p class="calibre_9">现在 CSV 文件中的内容就是按姓氏排序的了：</p><p class="calibre_7"><img src="images/00136.jpg" class="calibre_89"/><br class="calibre3"/></p><p class="calibre_7">Vim 提供了一种方便的快捷方式来设置<span class="bold">:[range]!{filter}</span>命令中的范围。我们可以用<span class="bold">!{motion}</span>操作符切换到命令行模式，并把指定<span class="bold">{motion}</span>所涵盖的范围预置在命令行上（参见<span class="bold">:h !</span><img src="images/00243.jpg" class="calibre_10"/>）。举个例子，如果我们把光标移到第2行，然后执行<span class="bold">!G</span>，Vim 就会打开命令行并把范围<span class="bold">:.,$!</span>预置在命令行上。虽然此后我们仍需输入剩下的<span class="bold">{filter}</span>命令，但这毕竟节省了部分工作。</p><p class="calibre_8"><span class="calibre2"><span class="bold">结论</span></span></p><p class="calibre_9">在 Vim中操作时，我们能很方便地调用shell命令。下表选取了最有用的一些调用外部命令的方式：</p><p class="calibre3" style="margin:0pt; border:0pt; height:1em"> </p><table valign="top" class="calibre_18"><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20"><span class="bold">  命令  </span>
</td><td colspan="1" rowspan="1" valign="top" class="calibre_20"><span class="bold">  用途  </span>
</td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  :shell   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  启动一个shell (输入exit返回Vim)   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  :!{cmd}   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  在shell中执行{cmd}   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  :read !{cmd}   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  在shell中执行{cmd}，并把其标准输出插入到光标下方   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  :[range]write !{cmd}   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  在shell中执行{cmd}，以[range]作为其标准输入   </td></tr><tr valign="top" class="calibre_19"><td colspan="1" rowspan="1" valign="top" class="calibre_20">  :[range]!{filter}   </td><td colspan="1" rowspan="1" valign="top" class="calibre_20">  使用外部程序{filter}过滤指定的[range]   </td></tr></table><p class="calibre_6">Vim 对某些外部命令会另眼相待。例如，<span class="bold">make</span>及<span class="bold">grep</span>在 Vim 中都有包装命令，这些命令不仅执行起来更方便，而且Vim还会将它们的输出解析、导入到 quickfix 列表中。我们将在第17章和第18章用很大篇幅介绍这两条命令。</p><p class="calibre_5">
<a></a>
</p><p class="calibre_6">第二部分文件</p><p class="calibre_6">在本书的这一部分，我们将学习如何使用文件及缓冲区。Vim允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。另外，我们还会看到在Vim中打开文件的几种不同方式，并掌握一些方法来解决无法把缓冲区保存到文件的问题。</p><p class="calibre_5">
<a id="filepos193149"></a><a href="index_split_032.html#filepos138425"><span class="calibre_2"><span class="underline">(1)</span></span></a> http://en.wikipedia.org/wiki/Teleprinter </p><p class="calibre_5">
<a id="filepos193312"></a><a href="index_split_032.html#filepos139180"><span class="calibre_2"><span class="underline">(2)</span></span></a> http://www.theregiscer.co.uk/2003/09111/biu-joys.greatert_gifo/ </p><div class="mbp_pagebreak" id="calibre_pb_45"></div>
</body></html>
