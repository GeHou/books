<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Vim实用技巧</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos566641" class="calibre_8"><span class="calibre1"><span class="bold">技巧99将TODO项收集至寄存器</span></span></p><p class="calibre_9"> 通过把:global 和:yank这两条命令结合在一起，我们可以把所有匹配{pattern}的文本行收集到某个寄存器中。 </p><p class="calibre_7">下列代码包含了几行以“TODO”开头的注释行：</p><p class="calibre_"><img src="images/00165.jpg" class="calibre_264"/></p><p class="calibre_7">假设我们想把所有TODO项收集到一起。只需输入以下命令，这些信息就会变得一览无余：</p><p class="calibre_8"><span class="bold">➾:g/TODO</span></p><p class="calibre_8">
<a></a>
</p><p class="calibre_5"><span class="calibre6"> 《 // TODO: Cache this regexp for certain depths.</span><br class="calibre3"/><span class="calibre6"> // TODO: No matching end code found - warn! </span></p><p class="calibre_7">请牢记，<span class="bold">:print</span>是<span class="bold">:global</span>命令的缺省<span class="bold">[cmd]</span>，它只是简单地回显所有匹配单词“TODO”的文本行。这并没什么用处，因为一旦执行了其他命令，这些信息将会消失。</p><p class="calibre_7">这里介绍另外一种做法。先将所有包含单词“TODO”的文本行复制到某个寄存器，再把寄存器的内容粘贴到其他文件中，以备不时之需。</p><p class="calibre_7">这一次，我们将用到寄存器a。首先要运行<span class="bold">qaq</span>，将其清空。我们对这个命令进行一下分解。<span class="bold">qa</span>会让vim开始录制宏，并把它存到寄存器a中，而最后的<span class="bold">q</span>则负责终止录制。由于在录制宏的过程中，我们没有敲击任何按键，因此寄存器最终被清空了。我们可以用下面的命令印证一下：</p><p class="calibre_8"><span class="bold">➾:reg a</span></p><p class="calibre_8"><span class="calibre6"> 《 --- Registers --- </span></p><p class="calibre_5"><span class="calibre6"> "a </span></p><p class="calibre_7">现在，我们可以把包含TODO注释的行复制到此寄存器中了：</p><p class="calibre_8"><span class="bold">➾:g/TODO/yank A </span></p><p class="calibre_8"><span class="bold">➾:reg a</span></p><p class="calibre_8"><span class="calibre6"> 《 "a // TODO: Cache this regexp for certain depths.</span><br class="calibre3"/><span class="calibre6"> // TODO: No matching end code found - warn! </span></p><p class="calibre_7">此处有一个窍门，即要用大写字母A引用寄存器。这意味着Vim将把内容附加到指定的寄存器，而用小写字母<span class="bold">a</span>的话，则会覆盖原有寄存器的内容。因此，这条global命令可以被解读为“将所有匹配模式 /TODO/ 的文本行依次附加到寄存器<span class="bold">a</span>。”</p><p class="calibre_7">这一次，当我们再次运行<span class="bold">:reg a</span>时，会发现寄存器<span class="bold">a</span>已经存有两组源自文档的TODO项了。（为了方便阅读，我已将这些内容调整为两行，但在Vim中，换行符实际会显示为^J。）此后，我们只需在任意分割窗口中打开一个新缓冲区，再运行<span class="bold">"ap</span>命令，就可以将寄存器<span class="bold">a</span>的内容粘贴进去了。</p><p class="calibre_8"><span class="calibre2"><span class="bold">结论</span></span></p><p class="calibre_9">在本例中，我们只收集了两个TODO项，即使手动操作也可以很快地完成。但是，以上介绍的技术具有很好的扩展性。如果某篇文档包含十几个TODO项，采用该技巧将使我们事半功倍。</p><p class="calibre_7">我们甚至可以将<span class="bold">:global</span>命令与<span class="bold">:bufdo</span>或<span class="bold">:argdo</span>一起搭配使用，从一组文件中收集所有的TODO项。这个任务就留给你作为练习吧，你可以参考技巧96中类似的工作流程。</p><p class="calibre_7">还有另外一种方案：</p><p class="calibre_8"><span class="bold">➾:g/TODO/t$</span></p><p class="calibre_9">这里用到的<span class="bold">:t</span>命令，已经在技巧29中有所介绍。该命令是将所有TODO项复制到当前文件的末尾，而不是把它们附加到寄存器。一旦运行完该命令，我们就可以在文件的末尾看到这些TODO项了。由于此法不会影响寄存器的内容，因此相对简单直接，但它在与<span class="bold">:argdo</span>以及 <span class="bold">:bufdo</span>命令一起使用时不太干净利落。</p><div class="mbp_pagebreak" id="calibre_pb_129"></div>
</body></html>
