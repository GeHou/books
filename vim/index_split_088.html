<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Vim实用技巧</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos446070" class="calibre_8"><span class="calibre1"><span class="bold">技巧76界定单词的边界</span></span></p><p class="calibre_9"> 在我们定义模式时，如果能指定单词从哪里开始到哪里结束的话，将会非常有用。Vim的单词定界符可以帮助我们做到这一点。 </p><p class="calibre_7">有些单词，尤其是短词，常常出现在其他单词内部。比如，“the”就会在“these”、“they”、“their”等单词中出现。因此，如果我们在下面这段文本中执行 /the<span class="bold">&lt;CR&gt;</span>进行查找的话，会发现实际匹配的内容比我们预想得要多。</p><p class="calibre_"><img src="images/00010.jpg" class="calibre_208"/></p><p class="calibre_7">如果我们想明确匹配“the”这个完整的单词而不是其他词的组成部分，可以使用单词定界符。在<span class="bold">very magic</span>搜索模式下，用 &lt;与&gt;符号表示单词定界符。因此，如果我们将查找命令改为 /\v&lt;the&gt;<span class="bold">&lt;CR&gt;</span>的话，文中就只会出现一处匹配了。</p><p class="calibre_7">这些就是所谓的零宽度元字符，它们本身不匹配任何字符，仅表示单词与围绕此单词的空白字符（或标点符号）之间的边界。</p><p class="calibre_7">我们可以将字符类<span class="bold">\w</span>、<span class="bold">\W</span>与匹配定界符<span class="bold">\zs</span>、<span class="bold">\ze</span>组合在一起，来模拟 &lt;与&gt;（我们将在技巧77中结识这种用法）。<span class="bold">\w</span>匹配单词类字符，包括字母、数字以及符号“<span class="bold">_</span>”，而<span class="bold">\W</span>则用来匹配除单词类字符以外的其他字符。</p><p class="calibre_6">使用圆括号，但不捕获其内容</p><p class="calibre_6"> 有时我们只想使用圆括号的分组功能，但并不关心所捕获的子匹配。例如，可以使用以下模式来匹配我名字的两种形式： </p><p class="calibre_8"><span class="bold">➾/\v(And|D)rew Neil</span></p><p class="calibre_9"> 这一次，我们使用圆括号的目的在于匹配“Andrew”或者“Drew”，但可能并不想捕获位于圆括号内部的“And或D”。我们可以在圆括号前面加上%，指示Vim不要将括号内的内容赋给寄存器\1，就像这样： </p><p class="calibre_8"><span class="bold">➾/\v%(And|D)rew Neil</span></p><p class="calibre_8">
<a></a>
</p><p class="calibre_7"> 运行结果与之前相比有区别么？当然，速度比原来快了一点，只是你可能察觉不到。但如果你发现自己经常会用到多组圆括号，这种方法就很有用处了。还以处理我名字的两种形式为例，假设我们想把所有的名和姓替换为姓和名。可以这样做： </p><p class="calibre_8"><span class="bold">➾/\v(%(And|D)rew) (Neil) </span></p><p class="calibre_8"><span class="bold">➾:%s//\2, \1/g</span></p><p class="calibre_9"> 该查找模式会把“Andrew”或者“Drew”赋给寄存器\1，而把“Neil”赋给寄存器\2。如果我们没有对第二组圆括号使用%()，便会得到无用的文本片段，从而扰乱替换域。 </p><p class="calibre_7">将这些命令合而为一，我们可以用<span class="bold">\W\ze\w</span>模拟元字符 &lt;，而用<span class="bold">\w\ze\W</span>表示元字符 &gt;。</p><p class="calibre_7">在<span class="bold">very magic</span>搜索模式下，&lt;与&gt;字符可直接被解析为单词定界符，而在magic、nomagic以及<span class="bold">very nomagic</span>搜索模式下，则必须要将它们转义。因此，要想在Vim文档中查阅这些选项，我们得在前面附加一个斜杠，即：h <span class="bold">/\&lt;</span><img src="images/00243.jpg" class="calibre_10"/>。</p><p class="calibre_7"> 注意：如果想在very magic搜索模式下匹配尖括号本身的话，必须将其转义。 </p><p class="calibre_7">即使我们还没养成用单词定界符构造查找模式的习惯，但每当我们使用<span class="bold">*</span>或者<span class="bold">#</span>命令（参见<span class="bold">:h *</span><img src="images/00243.jpg" class="calibre_10"/>）时就会间接地用到它们。这两条查找命令分别用于正向或反向查找光标下的单词。假设我们刚刚用过这两条命令中的某一个，在查看查找历史（按 /<span class="bold">&lt;UP&gt;</span>）时就会发现，上一次的查找模式就被单词定界符围在中间。顺便说一句，<span class="bold">g*</span>与<span class="bold">g#</span> 这两种变体将执行同样的查找，但不会使用单词定界符。</p><div class="mbp_pagebreak" id="calibre_pb_100"></div>
</body></html>
