<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Vim实用技巧</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos523475" class="calibre_8"><span class="calibre1"><span class="bold">技巧91用寄存器的内容替换</span></span></p><p class="calibre_9"> 实际上，我们不必手动输入完整的替换字符串。如果某段文本已在当前文档中出现，我们可以先把它复制到寄存器，再通过传值或引用的方式将寄存器的内容应用至替换域。 </p><p class="calibre_7">我们已在技巧90中看到，当substitute命令的查找域为空时，Vim做出了智能的选择。人们不禁会想，如果将替换域留空的话，substitute命令也一样会重用上一次的字符串吧？但事实并非如此。将替换域留空，意味着substitute命令会用空的字符串替换每一处匹配。换句话说，所有的匹配都被删除了。</p><p class="calibre_8"><span class="calibre3"><span class="bold">传值</span></span></p><p class="calibre_9">通过输入<span class="bold">&lt;C-r&gt;{register}</span>，我们可以将寄存器的内容插入到命令行。假设我们已经复制了一些文本，如果要将它们粘贴到substitute命令的替换域，需要输入以下命令：</p><p class="calibre_8"><span class="bold">➾:%s//&lt;C-r&gt;0/g</span></p><p class="calibre_9">当我们输入<span class="bold">&lt;C-r&gt;0</span>时，Vim会把寄存器0的内容粘贴进来，这意味着我们可以在执行substitute命令之前对其进行一番检查。在大多数情况下，它工作得都很好，但也引入了新的问题。</p><p class="calibre_7">如果寄存器0中的文本包含了在替换域中具有特殊含义的字符（例如<span class="bold">&amp;</span>或～），我们必须手动编辑这段文本，对这些字符进行转义。另外，如果寄存器0包含多行文本，有可能在命令行上显示不全。</p><p class="calibre_7">为了避免这些问题，我们可以在替换域中简单地引用某个寄存器，从而得到该寄存器的内容。</p><p class="calibre_8"><span class="calibre3"><span class="bold">引用</span></span></p><p class="calibre_9">假设我们已经复制了多行文本，并存放于寄存器0中。我们现在的目标是在substitute命令的替换域中使用这段文本。通过运行以下命令，可以做到这一点：</p><p class="calibre_8"><span class="bold">➾:%s//\=@0/g</span></p><p class="calibre_9">替换域中出现的<span class="bold">\=</span>将指示 Vim执行一段表达式脚本。在Vim脚本中，我们可以用<span class="bold">@{register}</span>来引用某个寄存器的内容。具体来说，<span class="bold">@</span>0会返回复制专用寄存器的内容，而<span class="bold">@"</span>则返回无名寄存器的内容。因此，表达式<span class="bold">:%s//\=@</span>0<span class="bold">/g</span>表示Vim将会用复制专用寄存器的内容替换上一次的模式。</p><p class="calibre_5">
<a class="calibre2"></a>
</p><p class="calibre_8"><span class="calibre3"><span class="bold">比较</span></span></p><p class="calibre_9">先看一下这条命令：</p><p class="calibre_8"><span class="bold">➾:%s/Pragmatic Vim/Practical Vim/g</span></p><p class="calibre_9">再与以下命令序列进行比较：</p><p class="calibre_8"><span class="bold">➾:let @/='Pragmatic Vim' </span></p><p class="calibre_8"><span class="bold">➾:let @a='Practical Vim' </span></p><p class="calibre_8"><span class="bold">➾:%s//\=@a/g</span></p><p class="calibre_9">其中，<span class="bold">:let @/='Pragmatic Vim'</span>是采用编程的方式输入查找模式，它等同于直接执行查找命令<span class="bold">/Pragmatic Vim&lt;CR&gt;</span>（有一点不同，即运行<span class="bold">:let @/='Pragmatic Vim'</span>不会在查找历史中留下任何记录）。</p><p class="calibre_7">同样的道理，<span class="bold">:let @a='Practical Vim'</span>表示设置<span class="bold">a</span>寄存器的内容。它等同于高亮选中“Practical Vim”并用<span class="bold">"ay</span>将选中的文本存入寄存器<span class="bold">a</span>。</p><p class="calibre_7">这两条substitute命令都完成同一件事，即把所有“Pragmatic Vim”替换为“Practical Vim”。但我们要考虑一下它们各自的影响。</p><p class="calibre_7">第一种方法，会在命令历史中留下一项内容为<span class="bold">:%s/Pragmatic Vim/Practical Vim/g</span>的记录，使人一目了然。在稍后的编辑过程中，如果我们意识到要重复这条命令的话，可直接从命令历史中调出该项记录，即可加以执行。总之，不会有什么意外发生。</p><p class="calibre_7">而第二种方法，会在命令历史中留下一项内容为<span class="bold">:%s//\=@a/g</span>的记录。这看上去是不是相当神秘呢？</p><p class="calibre_7">试想一下，当我们首次运行substitute命令时，查找模式为“Pragmatic Vim”，而寄存器<span class="bold">a</span>包含文本“Practical Vim”。但是半小时之后，当前的查找模式可能已经被多次修改了，而且寄存器<span class="bold">a</span>也可能被其他内容所覆盖。因此，如果我们重复<span class="bold">:%s//\=@a/g</span>命令的话，结果会与第一次执行这条命令时截然不同。</p><p class="calibre_7">我们可以利用这一特点。首先，我们查找要操作的文本，并将替换的内容复制到寄存器<span class="bold">a</span>中。之后，我们可以重复调用命令<span class="bold">:%s//\=@a/g</span>，而该命令会使用刚刚被赋值的<span class="bold">@/</span>和<span class="bold">@a</span>中的内容。接下来，我们可以查找新的文本，并复制新的替换字符串至寄存器<span class="bold">a</span>。而当我们再次重复<span class="bold">:%s//\=@a/g</span>命令时，运行结果将会迥然不同。</p><p class="calibre_7">此法不妨一试。你或许会爱上它，也可能会讨厌它。但无论哪种情况，都是不错的技巧。</p><div class="mbp_pagebreak" id="calibre_pb_119"></div>
</body></html>
