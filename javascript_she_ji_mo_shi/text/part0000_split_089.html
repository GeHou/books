<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 id="nav_point_127" class="calibre7"><strong class="calibre6">9.8　智能命令与傻瓜命令</strong></h2>
<p class="calibre1">再看一下我们在9.7节创建的命令：</p>
<pre class="Dai Ma Wu Xing Hao "><code class="calibre9">var closeDoorCommand = {
    execute: function(){
        console.log( '关门' );
    }
};

</code></pre>
<p class="calibre1">很奇怪，<code class="calibre9">closeDoorCommand</code>中没有包含任何<code class="calibre9">receiver</code>的信息，它本身就包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个<code class="calibre9">receiver</code>是矛盾的。</p>
<p class="calibre1">一般来说，命令模式都会在<code class="calibre9">command</code>对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。</p>
<p class="calibre1">但是我们也可以定义一些更“聪明”的命令对象，“聪明”的命令对象可以直接实现请求，这样一来就不再需要接收者的存在，这种“聪明”的命令对象也叫作智能命令。没有接收者的智能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图的不同。策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对“算法”而言的。而智能命令模式指向的问题域更广，<code class="calibre9">command</code>对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。</p>
</body></html>
