<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="toc-level"><a href="part0000_split_002.html#nav_point_0" class="calibre5">序</a></p><p class="toc-level1"><a href="part0000_split_003.html#nav_point_1" class="calibre5">本书结构</a></p><p class="toc-level1"><a href="part0000_split_004.html#nav_point_2" class="calibre5">目标读者</a></p><p class="toc-level1"><a href="part0000_split_005.html#nav_point_3" class="calibre5">示例代码与勘误</a></p><p class="toc-level1"><a href="part0000_split_006.html#nav_point_4" class="calibre5">致谢</a></p><p class="toc-level"><a href="part0000_split_007.html#nav_point_5" class="calibre5">前言</a></p><p class="toc-level1"><a href="part0000_split_008.html#nav_point_6" class="calibre5">学习模式的作用</a></p><p class="toc-level1"><a href="part0000_split_009.html#nav_point_7" class="calibre5">模式在不同语言之间的区别</a></p><p class="toc-level1"><a href="part0000_split_010.html#nav_point_8" class="calibre5">设计模式的适用性</a></p><p class="toc-level1"><a href="part0000_split_011.html#nav_point_9" class="calibre5">分辨模式的关键是意图而不是结构</a></p><p class="toc-level1"><a href="part0000_split_012.html#nav_point_10" class="calibre5">对JavaScript设计模式的误解</a></p><p class="toc-level1"><a href="part0000_split_013.html#nav_point_11" class="calibre5">模式的发展</a></p><p class="toc-level"><a href="part0000_split_014.html#nav_point_12" class="calibre5">第一部分　基础知识</a></p><p class="toc-level"><a href="part0000_split_015.html#nav_point_13" class="calibre5">第 1 章　面向对象的JavaScript</a></p><p class="toc-level1"><a href="part0000_split_016.html#nav_point_14" class="calibre5">1.1　动态类型语言和鸭子类型</a></p><p class="toc-level1"><a href="part0000_split_017.html#nav_point_15" class="calibre5">1.2　多态</a></p><p class="toc-level2"><a href="part0000_split_017.html#nav_point_16" class="calibre5">1.2.1　一段“多态”的JavaScript代码</a></p><p class="toc-level2"><a href="part0000_split_017.html#nav_point_17" class="calibre5">1.2.2　对象的多态性</a></p><p class="toc-level2"><a href="part0000_split_017.html#nav_point_18" class="calibre5">1.2.3　类型检查和多态</a></p><p class="toc-level2"><a href="part0000_split_017.html#nav_point_19" class="calibre5">1.2.4　使用继承得到多态效果</a></p><p class="toc-level2"><a href="part0000_split_017.html#nav_point_20" class="calibre5">1.2.5　JavaScript的多态</a></p><p class="toc-level2"><a href="part0000_split_017.html#nav_point_21" class="calibre5">1.2.6　多态在面向对象程序设计中的作用</a></p><p class="toc-level2"><a href="part0000_split_017.html#nav_point_22" class="calibre5">1.2.7　设计模式与多态</a></p><p class="toc-level1"><a href="part0000_split_018.html#nav_point_23" class="calibre5">1.3　封装</a></p><p class="toc-level2"><a href="part0000_split_018.html#nav_point_24" class="calibre5">1.3.1　封装数据</a></p><p class="toc-level2"><a href="part0000_split_018.html#nav_point_25" class="calibre5">1.3.2　封装实现</a></p><p class="toc-level2"><a href="part0000_split_018.html#nav_point_26" class="calibre5">1.3.3　封装类型</a></p><p class="toc-level2"><a href="part0000_split_018.html#nav_point_27" class="calibre5">1.3.4　封装变化</a></p><p class="toc-level1"><a href="part0000_split_019.html#nav_point_28" class="calibre5">1.4　原型模式和基于原型继承的JavaScript对象系统</a></p><p class="toc-level2"><a href="part0000_split_019.html#nav_point_29" class="calibre5">1.4.1　使用克隆的原型模式</a></p><p class="toc-level2"><a href="part0000_split_019.html#nav_point_30" class="calibre5">1.4.2　克隆是创建对象的手段</a></p><p class="toc-level2"><a href="part0000_split_019.html#nav_point_31" class="calibre5">1.4.3　体验Io语言</a></p><p class="toc-level2"><a href="part0000_split_019.html#nav_point_32" class="calibre5">1.4.4　原型编程范型的一些规则</a></p><p class="toc-level2"><a href="part0000_split_019.html#nav_point_33" class="calibre5">1.4.5　JavaScript中的原型继承</a></p><p class="toc-level2"><a href="part0000_split_019.html#nav_point_34" class="calibre5">1.4.6　原型继承的未来</a></p><p class="toc-level2"><a href="part0000_split_019.html#nav_point_35" class="calibre5">1.4.6　小结</a></p><p class="toc-level"><a href="part0000_split_020.html#nav_point_36" class="calibre5">第 2 章　this、call和apply</a></p><p class="toc-level1"><a href="part0000_split_021.html#nav_point_37" class="calibre5">2.1　this</a></p><p class="toc-level2"><a href="part0000_split_021.html#nav_point_38" class="calibre5">2.1.1　this的指向</a></p><p class="toc-level2"><a href="part0000_split_021.html#nav_point_39" class="calibre5">2.1.2　丢失的this</a></p><p class="toc-level1"><a href="part0000_split_022.html#nav_point_40" class="calibre5">2.2　call和apply</a></p><p class="toc-level2"><a href="part0000_split_022.html#nav_point_41" class="calibre5">2.2.1　call和apply的区别</a></p><p class="toc-level2"><a href="part0000_split_022.html#nav_point_42" class="calibre5">2.2.2　call和apply的用途</a></p><p class="toc-level"><a href="part0000_split_023.html#nav_point_43" class="calibre5">第 3 章　闭包和高阶函数</a></p><p class="toc-level1"><a href="part0000_split_024.html#nav_point_44" class="calibre5">3.1　闭包</a></p><p class="toc-level2"><a href="part0000_split_024.html#nav_point_45" class="calibre5">3.1.1　变量的作用域</a></p><p class="toc-level2"><a href="part0000_split_024.html#nav_point_46" class="calibre5">3.1.2　变量的生存周期</a></p><p class="toc-level2"><a href="part0000_split_024.html#nav_point_47" class="calibre5">3.1.3　闭包的更多作用</a></p><p class="toc-level2"><a href="part0000_split_024.html#nav_point_48" class="calibre5">3.1.4　闭包和面向对象设计</a></p><p class="toc-level2"><a href="part0000_split_024.html#nav_point_49" class="calibre5">3.1.5　用闭包实现命令模式</a></p><p class="toc-level2"><a href="part0000_split_024.html#nav_point_50" class="calibre5">3.1.6　闭包与内存管理</a></p><p class="toc-level1"><a href="part0000_split_025.html#nav_point_51" class="calibre5">3.2　高阶函数</a></p><p class="toc-level2"><a href="part0000_split_025.html#nav_point_52" class="calibre5">3.2.1　函数作为参数传递</a></p><p class="toc-level2"><a href="part0000_split_025.html#nav_point_53" class="calibre5">3.2.2　函数作为返回值输出</a></p><p class="toc-level2"><a href="part0000_split_025.html#nav_point_54" class="calibre5">3.2.3　高阶函数实现AOP</a></p><p class="toc-level2"><a href="part0000_split_025.html#nav_point_55" class="calibre5">3.2.4　高阶函数的其他应用</a></p><p class="toc-level1"><a href="part0000_split_026.html#nav_point_56" class="calibre5">3.3　小结</a></p><p class="toc-level"><a href="part0000_split_027.html#nav_point_57" class="calibre5">第二部分　设计模式</a></p><p class="toc-level"><a href="part0000_split_028.html#nav_point_58" class="calibre5">第 4 章　单例模式</a></p><p class="toc-level1"><a href="part0000_split_029.html#nav_point_59" class="calibre5">4.1　实现单例模式</a></p><p class="toc-level1"><a href="part0000_split_030.html#nav_point_60" class="calibre5">4.2　透明的单例模式</a></p><p class="toc-level1"><a href="part0000_split_031.html#nav_point_61" class="calibre5">4.3　用代理实现单例模式</a></p><p class="toc-level1"><a href="part0000_split_032.html#nav_point_62" class="calibre5">4.4　JavaScript中的单例模式</a></p><p class="toc-level1"><a href="part0000_split_033.html#nav_point_63" class="calibre5">4.5　惰性单例</a></p><p class="toc-level1"><a href="part0000_split_034.html#nav_point_64" class="calibre5">4.6　通用的惰性单例</a></p><p class="toc-level1"><a href="part0000_split_035.html#nav_point_65" class="calibre5">4.7　小结</a></p><p class="toc-level"><a href="part0000_split_036.html#nav_point_66" class="calibre5">第 5 章　策略模式</a></p><p class="toc-level1"><a href="part0000_split_037.html#nav_point_67" class="calibre5">5.1　使用策略模式计算奖金</a></p><p class="toc-level1"><a href="part0000_split_038.html#nav_point_68" class="calibre5">5.2　JavaScript版本的策略模式</a></p><p class="toc-level1"><a href="part0000_split_039.html#nav_point_69" class="calibre5">5.3　多态在策略模式中的体现</a></p><p class="toc-level1"><a href="part0000_split_040.html#nav_point_70" class="calibre5">5.4　使用策略模式实现缓动动画</a></p><p class="toc-level2"><a href="part0000_split_040.html#nav_point_71" class="calibre5">5.4.1　实现动画效果的原理</a></p><p class="toc-level2"><a href="part0000_split_040.html#nav_point_72" class="calibre5">5.4.2　思路和一些准备工作</a></p><p class="toc-level2"><a href="part0000_split_040.html#nav_point_73" class="calibre5">5.4.3　让小球运动起来</a></p><p class="toc-level1"><a href="part0000_split_041.html#nav_point_74" class="calibre5">5.5　更广义的“算法”</a></p><p class="toc-level1"><a href="part0000_split_042.html#nav_point_75" class="calibre5">5.6　表单校验</a></p><p class="toc-level2"><a href="part0000_split_042.html#nav_point_76" class="calibre5">5.6.1　表单校验的第一个版本</a></p><p class="toc-level2"><a href="part0000_split_042.html#nav_point_77" class="calibre5">5.6.2　用策略模式重构表单校验</a></p><p class="toc-level2"><a href="part0000_split_042.html#nav_point_78" class="calibre5">5.6.3　给某个文本输入框添加多种校验规则</a></p><p class="toc-level1"><a href="part0000_split_043.html#nav_point_79" class="calibre5">5.7　策略模式的优缺点</a></p><p class="toc-level1"><a href="part0000_split_044.html#nav_point_80" class="calibre5">5.8　一等函数对象与策略模式</a></p><p class="toc-level1"><a href="part0000_split_045.html#nav_point_81" class="calibre5">5.9　小结</a></p><p class="toc-level"><a href="part0000_split_046.html#nav_point_82" class="calibre5">第 6 章　代理模式</a></p><p class="toc-level1"><a href="part0000_split_047.html#nav_point_83" class="calibre5">6.1　第一个例子——小明追MM的故事</a></p><p class="toc-level1"><a href="part0000_split_048.html#nav_point_84" class="calibre5">6.2　保护代理和虚拟代理</a></p><p class="toc-level1"><a href="part0000_split_049.html#nav_point_85" class="calibre5">6.3　虚拟代理实现图片预加载</a></p><p class="toc-level1"><a href="part0000_split_050.html#nav_point_86" class="calibre5">6.4　代理的意义</a></p><p class="toc-level1"><a href="part0000_split_051.html#nav_point_87" class="calibre5">6.5　代理和本体接口的一致性</a></p><p class="toc-level1"><a href="part0000_split_052.html#nav_point_88" class="calibre5">6.6　虚拟代理合并HTTP请求</a></p><p class="toc-level1"><a href="part0000_split_053.html#nav_point_89" class="calibre5">6.7　虚拟代理在惰性加载中的应用</a></p><p class="toc-level1"><a href="part0000_split_054.html#nav_point_90" class="calibre5">6.8　缓存代理</a></p><p class="toc-level2"><a href="part0000_split_054.html#nav_point_91" class="calibre5">6.8.1　缓存代理的例子——计算乘积</a></p><p class="toc-level2"><a href="part0000_split_054.html#nav_point_92" class="calibre5">6.8.2　缓存代理用于ajax异步请求数据</a></p><p class="toc-level1"><a href="part0000_split_055.html#nav_point_93" class="calibre5">6.9　用高阶函数动态创建代理</a></p><p class="toc-level1"><a href="part0000_split_056.html#nav_point_94" class="calibre5">6.10　其他代理模式</a></p><p class="toc-level1"><a href="part0000_split_057.html#nav_point_95" class="calibre5">6.11　小结</a></p><p class="toc-level"><a href="part0000_split_058.html#nav_point_96" class="calibre5">第 7 章　迭代器模式</a></p><p class="toc-level1"><a href="part0000_split_059.html#nav_point_97" class="calibre5">7.1　jQuery中的迭代器</a></p><p class="toc-level1"><a href="part0000_split_060.html#nav_point_98" class="calibre5">7.2　实现自己的迭代器</a></p><p class="toc-level1"><a href="part0000_split_061.html#nav_point_99" class="calibre5">7.3　内部迭代器和外部迭代器</a></p><p class="toc-level1"><a href="part0000_split_062.html#nav_point_100" class="calibre5">7.4　迭代类数组对象和字面量对象</a></p><p class="toc-level1"><a href="part0000_split_063.html#nav_point_101" class="calibre5">7.5　倒序迭代器</a></p><p class="toc-level1"><a href="part0000_split_064.html#nav_point_102" class="calibre5">7.6　中止迭代器</a></p><p class="toc-level1"><a href="part0000_split_065.html#nav_point_103" class="calibre5">7.7　迭代器模式的应用举例</a></p><p class="toc-level1"><a href="part0000_split_066.html#nav_point_104" class="calibre5">7.8　小结</a></p><p class="toc-level"><a href="part0000_split_067.html#nav_point_105" class="calibre5">第 8 章　发布—订阅模式</a></p><p class="toc-level1"><a href="part0000_split_068.html#nav_point_106" class="calibre5">8.1　现实中的发布－订阅模式</a></p><p class="toc-level1"><a href="part0000_split_069.html#nav_point_107" class="calibre5">8.2　发布－订阅模式的作用</a></p><p class="toc-level1"><a href="part0000_split_070.html#nav_point_108" class="calibre5">8.3　DOM事件</a></p><p class="toc-level1"><a href="part0000_split_071.html#nav_point_109" class="calibre5">8.4　自定义事件</a></p><p class="toc-level1"><a href="part0000_split_072.html#nav_point_110" class="calibre5">8.5　发布－订阅模式的通用实现</a></p><p class="toc-level1"><a href="part0000_split_073.html#nav_point_111" class="calibre5">8.6　取消订阅的事件</a></p><p class="toc-level1"><a href="part0000_split_074.html#nav_point_112" class="calibre5">8.7　真实的例子——网站登录</a></p><p class="toc-level1"><a href="part0000_split_075.html#nav_point_113" class="calibre5">8.8　全局的发布－订阅对象</a></p><p class="toc-level1"><a href="part0000_split_076.html#nav_point_114" class="calibre5">8.9　模块间通信</a></p><p class="toc-level1"><a href="part0000_split_077.html#nav_point_115" class="calibre5">8.10　必须先订阅再发布吗</a></p><p class="toc-level1"><a href="part0000_split_078.html#nav_point_116" class="calibre5">8.11　全局事件的命名冲突</a></p><p class="toc-level1"><a href="part0000_split_079.html#nav_point_117" class="calibre5">8.12　JavaScript实现发布－订阅模式的便利性</a></p><p class="toc-level1"><a href="part0000_split_080.html#nav_point_118" class="calibre5">8.13　小结</a></p><p class="toc-level"><a href="part0000_split_081.html#nav_point_119" class="calibre5">第 9 章　命令模式</a></p><p class="toc-level1"><a href="part0000_split_082.html#nav_point_120" class="calibre5">9.1　命令模式的用途</a></p><p class="toc-level1"><a href="part0000_split_083.html#nav_point_121" class="calibre5">9.2　命令模式的例子——菜单程序</a></p><p class="toc-level1"><a href="part0000_split_084.html#nav_point_122" class="calibre5">9.3　JavaScript中的命令模式</a></p><p class="toc-level1"><a href="part0000_split_085.html#nav_point_123" class="calibre5">9.4　撤销命令</a></p><p class="toc-level1"><a href="part0000_split_086.html#nav_point_124" class="calibre5">9.5　撤消和重做</a></p><p class="toc-level1"><a href="part0000_split_087.html#nav_point_125" class="calibre5">9.6　命令队列</a></p><p class="toc-level1"><a href="part0000_split_088.html#nav_point_126" class="calibre5">9.7　宏命令</a></p><p class="toc-level1"><a href="part0000_split_089.html#nav_point_127" class="calibre5">9.8　智能命令与傻瓜命令</a></p><p class="toc-level1"><a href="part0000_split_090.html#nav_point_128" class="calibre5">9.9　小结</a></p><p class="toc-level"><a href="part0000_split_091.html#nav_point_129" class="calibre5">第 10 章　组合模式</a></p><p class="toc-level1"><a href="part0000_split_092.html#nav_point_130" class="calibre5">10.1　回顾宏命令</a></p><p class="toc-level1"><a href="part0000_split_093.html#nav_point_131" class="calibre5">10.2　组合模式的用途</a></p><p class="toc-level1"><a href="part0000_split_094.html#nav_point_132" class="calibre5">10.3　请求在树中传递的过程</a></p><p class="toc-level1"><a href="part0000_split_095.html#nav_point_133" class="calibre5">10.4　更强大的宏命令</a></p><p class="toc-level1"><a href="part0000_split_096.html#nav_point_134" class="calibre5">10.5　抽象类在组合模式中的作用</a></p><p class="toc-level1"><a href="part0000_split_097.html#nav_point_135" class="calibre5">10.6　透明性带来的安全问题</a></p><p class="toc-level1"><a href="part0000_split_098.html#nav_point_136" class="calibre5">10.7　组合模式的例子——扫描文件夹</a></p><p class="toc-level1"><a href="part0000_split_099.html#nav_point_137" class="calibre5">10.8　一些值得注意的地方</a></p><p class="toc-level1"><a href="part0000_split_100.html#nav_point_138" class="calibre5">10.9　引用父对象</a></p><p class="toc-level1"><a href="part0000_split_101.html#nav_point_139" class="calibre5">10.10　何时使用组合模式</a></p><p class="toc-level1"><a href="part0000_split_102.html#nav_point_140" class="calibre5">10.11　小结</a></p><p class="toc-level"><a href="part0000_split_103.html#nav_point_141" class="calibre5">第 11 章　模板方法模式</a></p><p class="toc-level1"><a href="part0000_split_104.html#nav_point_142" class="calibre5">11.1　模板方法模式的定义和组成</a></p><p class="toc-level1"><a href="part0000_split_105.html#nav_point_143" class="calibre5">11.2　第一个例子——Coffee or Tea</a></p><p class="toc-level2"><a href="part0000_split_105.html#nav_point_144" class="calibre5">11.2.1　先泡一杯咖啡</a></p><p class="toc-level2"><a href="part0000_split_105.html#nav_point_145" class="calibre5">11.2.2　泡一壶茶</a></p><p class="toc-level2"><a href="part0000_split_105.html#nav_point_146" class="calibre5">11.2.3　分离出共同点</a></p><p class="toc-level2"><a href="part0000_split_105.html#nav_point_147" class="calibre5">11.2.4　创建Coffee子类和Tea子类</a></p><p class="toc-level1"><a href="part0000_split_106.html#nav_point_148" class="calibre5">11.3　抽象类</a></p><p class="toc-level2"><a href="part0000_split_106.html#nav_point_149" class="calibre5">11.3.1　抽象类的作用</a></p><p class="toc-level2"><a href="part0000_split_106.html#nav_point_150" class="calibre5">11.3.2　抽象方法和具体方法</a></p><p class="toc-level2"><a href="part0000_split_106.html#nav_point_151" class="calibre5">11.3.3　用Java实现Coffee or Tea的例子</a></p><p class="toc-level2"><a href="part0000_split_106.html#nav_point_152" class="calibre5">11.3.4　JavaScript没有抽象类的缺点和解决方案</a></p><p class="toc-level1"><a href="part0000_split_107.html#nav_point_153" class="calibre5">11.4　模板方法模式的使用场景</a></p><p class="toc-level1"><a href="part0000_split_108.html#nav_point_154" class="calibre5">11.5　钩子方法</a></p><p class="toc-level1"><a href="part0000_split_109.html#nav_point_155" class="calibre5">11.6　好莱坞原则</a></p><p class="toc-level1"><a href="part0000_split_110.html#nav_point_156" class="calibre5">11.7　真的需要“继承”吗</a></p><p class="toc-level1"><a href="part0000_split_111.html#nav_point_157" class="calibre5">11.8　小结</a></p><p class="toc-level"><a href="part0000_split_112.html#nav_point_158" class="calibre5">第 12 章　享元模式</a></p><p class="toc-level1"><a href="part0000_split_113.html#nav_point_159" class="calibre5">12.1　初识享元模式</a></p><p class="toc-level1"><a href="part0000_split_114.html#nav_point_160" class="calibre5">12.2　内部状态与外部状态</a></p><p class="toc-level1"><a href="part0000_split_115.html#nav_point_161" class="calibre5">12.3　享元模式的通用结构</a></p><p class="toc-level1"><a href="part0000_split_116.html#nav_point_162" class="calibre5">12.4　文件上传的例子</a></p><p class="toc-level2"><a href="part0000_split_116.html#nav_point_163" class="calibre5">12.4.1　对象爆炸</a></p><p class="toc-level2"><a href="part0000_split_116.html#nav_point_164" class="calibre5">12.4.2　享元模式重构文件上传</a></p><p class="toc-level2"><a href="part0000_split_116.html#nav_point_165" class="calibre5">12.4.3　剥离外部状态</a></p><p class="toc-level2"><a href="part0000_split_116.html#nav_point_166" class="calibre5">12.4.4　工厂进行对象实例化</a></p><p class="toc-level2"><a href="part0000_split_116.html#nav_point_167" class="calibre5">12.4.5　管理器封装外部状态</a></p><p class="toc-level1"><a href="part0000_split_117.html#nav_point_168" class="calibre5">12.5　享元模式的适用性</a></p><p class="toc-level1"><a href="part0000_split_118.html#nav_point_169" class="calibre5">12.6　再谈内部状态和外部状态</a></p><p class="toc-level2"><a href="part0000_split_118.html#nav_point_170" class="calibre5">12.6.1　没有内部状态的享元</a></p><p class="toc-level2"><a href="part0000_split_118.html#nav_point_171" class="calibre5">12.6.2　没有外部状态的享元</a></p><p class="toc-level1"><a href="part0000_split_119.html#nav_point_172" class="calibre5">12.7　对象池</a></p><p class="toc-level2"><a href="part0000_split_119.html#nav_point_173" class="calibre5">12.7.1　对象池实现</a></p><p class="toc-level2"><a href="part0000_split_119.html#nav_point_174" class="calibre5">12.7.2　通用对象池实现</a></p><p class="toc-level1"><a href="part0000_split_120.html#nav_point_175" class="calibre5">12.8　小结</a></p><p class="toc-level"><a href="part0000_split_121.html#nav_point_176" class="calibre5">第 13 章　职责链模式</a></p><p class="toc-level1"><a href="part0000_split_122.html#nav_point_177" class="calibre5">13.1　现实中的职责链模式</a></p><p class="toc-level1"><a href="part0000_split_123.html#nav_point_178" class="calibre5">13.2　实际开发中的职责链模式</a></p><p class="toc-level1"><a href="part0000_split_124.html#nav_point_179" class="calibre5">13.3　用职责链模式重构代码</a></p><p class="toc-level1"><a href="part0000_split_125.html#nav_point_180" class="calibre5">13.4　灵活可拆分的职责链节点</a></p><p class="toc-level1"><a href="part0000_split_126.html#nav_point_181" class="calibre5">13.5　异步的职责链</a></p><p class="toc-level1"><a href="part0000_split_127.html#nav_point_182" class="calibre5">13.6　职责链模式的优缺点</a></p><p class="toc-level1"><a href="part0000_split_128.html#nav_point_183" class="calibre5">13.7　用AOP实现职责链</a></p><p class="toc-level1"><a href="part0000_split_129.html#nav_point_184" class="calibre5">13.8　用职责链模式获取文件上传对象</a></p><p class="toc-level1"><a href="part0000_split_130.html#nav_point_185" class="calibre5">13.9　小结</a></p><p class="toc-level"><a href="part0000_split_131.html#nav_point_186" class="calibre5">第 14 章　中介者模式</a></p><p class="toc-level1"><a href="part0000_split_132.html#nav_point_187" class="calibre5">14.1　现实中的中介者</a></p><p class="toc-level1"><a href="part0000_split_133.html#nav_point_188" class="calibre5">14.2　中介者模式的例子——泡泡堂游戏</a></p><p class="toc-level2"><a href="part0000_split_133.html#nav_point_189" class="calibre5">14.2.1　为游戏增加队伍</a></p><p class="toc-level2"><a href="part0000_split_133.html#nav_point_190" class="calibre5">14.2.2　玩家增多带来的困扰</a></p><p class="toc-level2"><a href="part0000_split_133.html#nav_point_191" class="calibre5">14.2.3　用中介者模式改造泡泡堂游戏</a></p><p class="toc-level1"><a href="part0000_split_134.html#nav_point_192" class="calibre5">14.3　中介者模式的例子——购买商品</a></p><p class="toc-level2"><a href="part0000_split_134.html#nav_point_193" class="calibre5">14.3.1　开始编写代码</a></p><p class="toc-level2"><a href="part0000_split_134.html#nav_point_194" class="calibre5">14.3.2　对象之间的联系</a></p><p class="toc-level2"><a href="part0000_split_134.html#nav_point_195" class="calibre5">14.3.3　可能遇到的困难</a></p><p class="toc-level2"><a href="part0000_split_134.html#nav_point_196" class="calibre5">14.3.4　引入中介者</a></p><p class="toc-level1"><a href="part0000_split_135.html#nav_point_197" class="calibre5">14.4　小结</a></p><p class="toc-level"><a href="part0000_split_136.html#nav_point_198" class="calibre5">第 15 章　装饰者模式</a></p><p class="toc-level1"><a href="part0000_split_137.html#nav_point_199" class="calibre5">15.1　模拟传统面向对象语言的装饰者模式</a></p><p class="toc-level1"><a href="part0000_split_138.html#nav_point_200" class="calibre5">15.2　装饰者也是包装器</a></p><p class="toc-level1"><a href="part0000_split_139.html#nav_point_201" class="calibre5">15.3　回到JavaScript的装饰者</a></p><p class="toc-level1"><a href="part0000_split_140.html#nav_point_202" class="calibre5">15.4　装饰函数</a></p><p class="toc-level1"><a href="part0000_split_141.html#nav_point_203" class="calibre5">15.5　用AOP装饰函数</a></p><p class="toc-level1"><a href="part0000_split_142.html#nav_point_204" class="calibre5">15.6　AOP的应用实例</a></p><p class="toc-level2"><a href="part0000_split_142.html#nav_point_205" class="calibre5">15.6.1　数据统计上报</a></p><p class="toc-level2"><a href="part0000_split_142.html#nav_point_206" class="calibre5">15.6.2　用AOP动态改变函数的参数</a></p><p class="toc-level2"><a href="part0000_split_142.html#nav_point_207" class="calibre5">15.6.3　插件式的表单验证</a></p><p class="toc-level1"><a href="part0000_split_143.html#nav_point_208" class="calibre5">15.7　装饰者模式和代理模式</a></p><p class="toc-level1"><a href="part0000_split_144.html#nav_point_209" class="calibre5">15.8　小结</a></p><p class="toc-level"><a href="part0000_split_145.html#nav_point_210" class="calibre5">第 16 章　状态模式</a></p><p class="toc-level1"><a href="part0000_split_146.html#nav_point_211" class="calibre5">16.1　初识状态模式</a></p><p class="toc-level2"><a href="part0000_split_146.html#nav_point_212" class="calibre5">16.1.1　第一个例子：电灯程序</a></p><p class="toc-level2"><a href="part0000_split_146.html#nav_point_213" class="calibre5">16.1.2　状态模式改进电灯程序</a></p><p class="toc-level1"><a href="part0000_split_147.html#nav_point_214" class="calibre5">16.2　状态模式的定义</a></p><p class="toc-level1"><a href="part0000_split_148.html#nav_point_215" class="calibre5">16.3　状态模式的通用结构</a></p><p class="toc-level1"><a href="part0000_split_149.html#nav_point_216" class="calibre5">16.4　缺少抽象类的变通方式</a></p><p class="toc-level1"><a href="part0000_split_150.html#nav_point_217" class="calibre5">16.5　另一个状态模式示例——文件上传</a></p><p class="toc-level2"><a href="part0000_split_150.html#nav_point_218" class="calibre5">16.5.1　更复杂的切换条件</a></p><p class="toc-level2"><a href="part0000_split_150.html#nav_point_219" class="calibre5">16.5.2　一些准备工作</a></p><p class="toc-level2"><a href="part0000_split_150.html#nav_point_220" class="calibre5">16.5.3　开始编写代码</a></p><p class="toc-level2"><a href="part0000_split_150.html#nav_point_221" class="calibre5">16.5.4　状态模式重构文件上传程序</a></p><p class="toc-level1"><a href="part0000_split_151.html#nav_point_222" class="calibre5">16.6　状态模式的优缺点</a></p><p class="toc-level1"><a href="part0000_split_152.html#nav_point_223" class="calibre5">16.7　状态模式中的性能优化点</a></p><p class="toc-level1"><a href="part0000_split_153.html#nav_point_224" class="calibre5">16.8　状态模式和策略模式的关系</a></p><p class="toc-level1"><a href="part0000_split_154.html#nav_point_225" class="calibre5">16.9　JavaScript版本的状态机</a></p><p class="toc-level1"><a href="part0000_split_155.html#nav_point_226" class="calibre5">16.10　表驱动的有限状态机</a></p><p class="toc-level1"><a href="part0000_split_156.html#nav_point_227" class="calibre5">16.11　实际项目中的其他状态机</a></p><p class="toc-level1"><a href="part0000_split_157.html#nav_point_228" class="calibre5">16.12　小结</a></p><p class="toc-level"><a href="part0000_split_158.html#nav_point_229" class="calibre5">第 17 章　适配器模式</a></p><p class="toc-level1"><a href="part0000_split_159.html#nav_point_230" class="calibre5">17.1　现实中的适配器</a></p><p class="toc-level1"><a href="part0000_split_160.html#nav_point_231" class="calibre5">17.2　适配器模式的应用</a></p><p class="toc-level1"><a href="part0000_split_161.html#nav_point_232" class="calibre5">17.3　小结</a></p><p class="toc-level"><a href="part0000_split_162.html#nav_point_233" class="calibre5">第三部分　设计原则和编程技巧</a></p><p class="toc-level"><a href="part0000_split_163.html#nav_point_234" class="calibre5">第 18 章　单一职责原则</a></p><p class="toc-level1"><a href="part0000_split_164.html#nav_point_235" class="calibre5">18.1　设计模式中的SRP原则</a></p><p class="toc-level1"><a href="part0000_split_165.html#nav_point_236" class="calibre5">18.2　何时应该分离职责</a></p><p class="toc-level1"><a href="part0000_split_166.html#nav_point_237" class="calibre5">18.3　违反SRP原则</a></p><p class="toc-level1"><a href="part0000_split_167.html#nav_point_238" class="calibre5">18.4　SRP原则的优缺点</a></p><p class="toc-level"><a href="part0000_split_168.html#nav_point_239" class="calibre5">第 19 章　最少知识原则</a></p><p class="toc-level1"><a href="part0000_split_169.html#nav_point_240" class="calibre5">19.1　减少对象之间的联系</a></p><p class="toc-level1"><a href="part0000_split_170.html#nav_point_241" class="calibre5">19.2　设计模式中的最少知识原则</a></p><p class="toc-level1"><a href="part0000_split_171.html#nav_point_242" class="calibre5">19.3　封装在最少知识原则中的体现</a></p><p class="toc-level"><a href="part0000_split_172.html#nav_point_243" class="calibre5">第 20 章　开放-封闭原则</a></p><p class="toc-level1"><a href="part0000_split_173.html#nav_point_244" class="calibre5">20.1　扩展window.onload函数</a></p><p class="toc-level1"><a href="part0000_split_174.html#nav_point_245" class="calibre5">20.2　开放和封闭</a></p><p class="toc-level1"><a href="part0000_split_175.html#nav_point_246" class="calibre5">20.3　用对象的多态性消除条件分支</a></p><p class="toc-level1"><a href="part0000_split_176.html#nav_point_247" class="calibre5">20.4　找出变化的地方</a></p><p class="toc-level1"><a href="part0000_split_177.html#nav_point_248" class="calibre5">20.5　设计模式中的开放－封闭原则</a></p><p class="toc-level1"><a href="part0000_split_178.html#nav_point_249" class="calibre5">20.6　开放－封闭原则的相对性</a></p><p class="toc-level1"><a href="part0000_split_179.html#nav_point_250" class="calibre5">20.7　接受第一次愚弄</a></p><p class="toc-level"><a href="part0000_split_180.html#nav_point_251" class="calibre5">第 21 章　接口和面向接口编程</a></p><p class="toc-level1"><a href="part0000_split_181.html#nav_point_252" class="calibre5">21.1　回到Java的抽象类</a></p><p class="toc-level1"><a href="part0000_split_182.html#nav_point_253" class="calibre5">21.2　interface</a></p><p class="toc-level1"><a href="part0000_split_183.html#nav_point_254" class="calibre5">21.3　JavaScript语言是否需要抽象类和interface</a></p><p class="toc-level1"><a href="part0000_split_184.html#nav_point_255" class="calibre5">21.4　用鸭子类型进行接口检查</a></p><p class="toc-level1"><a href="part0000_split_185.html#nav_point_256" class="calibre5">21.5　用TypeScript编写基于interface的命令模式</a></p><p class="toc-level"><a href="part0000_split_186.html#nav_point_257" class="calibre5">第 22 章　代码重构</a></p><p class="toc-level1"><a href="part0000_split_187.html#nav_point_258" class="calibre5">22.1　提炼函数</a></p><p class="toc-level1"><a href="part0000_split_188.html#nav_point_259" class="calibre5">22.2　合并重复的条件片段</a></p><p class="toc-level1"><a href="part0000_split_189.html#nav_point_260" class="calibre5">22.3　把条件分支语句提炼成函数</a></p><p class="toc-level1"><a href="part0000_split_190.html#nav_point_261" class="calibre5">22.4　合理使用循环</a></p><p class="toc-level1"><a href="part0000_split_191.html#nav_point_262" class="calibre5">22.5　提前让函数退出代替嵌套条件分支</a></p><p class="toc-level1"><a href="part0000_split_192.html#nav_point_263" class="calibre5">22.6　传递对象参数代替过长的参数列表</a></p><p class="toc-level1"><a href="part0000_split_193.html#nav_point_264" class="calibre5">22.7　尽量减少参数数量</a></p><p class="toc-level1"><a href="part0000_split_194.html#nav_point_265" class="calibre5">22.8　少用三目运算符</a></p><p class="toc-level1"><a href="part0000_split_195.html#nav_point_266" class="calibre5">22.9　合理使用链式调用</a></p><p class="toc-level1"><a href="part0000_split_196.html#nav_point_267" class="calibre5">22.10　分解大型类</a></p><p class="toc-level1"><a href="part0000_split_197.html#nav_point_268" class="calibre5">22.11　用return退出多重循环</a></p><p class="toc-level"><a href="part0000_split_198.html#nav_point_269" class="calibre5">参考文献</a></p><p class="calibre4" style="margin:0pt; border:0pt; height:1em" id="calibre_pb_3"> </p>
</body></html>
