<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-tw" xml:lang="zh-tw">
  <head>
    <title>Hello, World | Go语言圣经</title>
    <meta name="description" content=""/>
    <meta name="generator" content="GitBook 2.6.7"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="dir">
        
        
<div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_8">Hello, World</h1>
        
            <div class="section" id="section-">
            
                <h2 id="11-hello-world" class="calibre14">1.1. Hello, World</h2>
<p class="calibre6">我们以现已成为传统的“hello world”案例来开始吧, 这个例子首次出现于1978年出版的C语言圣经<a target="_blank" href="http://s3-us-west-2.amazonaws.com/belllabs-microsite-dritchie/cbook/index.html" class="pcalibre1 pcalibre2 pcalibre calibre7">《The C Programming Language》</a><sup class="calibre17"><a id="reffn_1" href="#fn_1" class="pcalibre1 pcalibre2 pcalibre calibre7">1</a></sup>。C语言是直接影响Go语言设计的语言之一。这个例子体现了Go语言一些核心理念。</p>
<p class="calibre6"><span class="calibre18"><i class="calibre13">gopl.io/ch1/helloworld</i></span></p>
<pre class="calibre15"><code class="pcalibre8 calibre16 pcalibre7"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-keyword">func</span> main() {
    fmt.Println(<span class="hljs-string">"Hello, 世界"</span>)
}
</code></pre>
<p class="calibre6">Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令<sup class="calibre17"><a id="reffn_2" href="#fn_2" class="pcalibre1 pcalibre2 pcalibre calibre7">2</a></sup>。Go语言提供的工具都通过一个单独的命令<code class="calibre12 pcalibre5 pcalibre6">go</code>调用，<code class="calibre12 pcalibre5 pcalibre6">go</code>命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。（本书使用$表示命令行提示符。）</p>
<pre class="calibre15"><code class="pcalibre8 calibre16 pcalibre7">$ go run helloworld.go
</code></pre><p class="calibre6">毫无意外，这个命令会输出：</p>
<pre class="calibre15"><code class="pcalibre8 calibre16 pcalibre7">Hello, 世界
</code></pre><p class="calibre6">Go语言原生支持Unicode，它可以处理全世界任何语言的文本。</p>
<p class="calibre6">如果不只是一次性实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以用build子命令：</p>
<pre class="calibre15"><code class="pcalibre8 calibre16 pcalibre7">$ go build helloworld.go
</code></pre><p class="calibre6">这个命令生成一个名为helloworld的可执行的二进制文件<sup class="calibre17"><a id="reffn_3" href="#fn_3" class="pcalibre1 pcalibre2 pcalibre calibre7">3</a></sup>，之后你可以随时运行它<sup class="calibre17"><a id="reffn_4" href="#fn_4" class="pcalibre1 pcalibre2 pcalibre calibre7">4</a></sup>，不需任何处理<sup class="calibre17"><a id="reffn_5" href="#fn_5" class="pcalibre1 pcalibre2 pcalibre calibre7">5</a></sup>。</p>
<pre class="calibre15"><code class="pcalibre8 calibre16 pcalibre7">$ ./helloworld
Hello, 世界
</code></pre><p class="calibre6">本书中, 所有的示例代码上都有一行标记，利用这些标记, 可以从<a target="_blank" href="http://gopl.io" class="pcalibre1 pcalibre2 pcalibre calibre7">gopl.io</a>网站上本书源码仓库里获取代码：</p>
<pre class="calibre15"><code class="pcalibre8 calibre16 pcalibre7">gopl.io/ch1/helloworld
</code></pre><p class="calibre6">执行 <code class="calibre12 pcalibre5 pcalibre6">go get gopl.io/ch1/helloworld</code> 命令，就会从网上获取代码，并放到对应目录中<sup class="calibre17"><a id="reffn_6" href="#fn_6" class="pcalibre1 pcalibre2 pcalibre calibre7">6</a></sup>。2.6和10.7节有这方面更详细的介绍。</p>
<p class="calibre6">来讨论下程序本身。Go语言的代码通过<strong class="calibre19">包</strong>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。每个源文件都以一条<code class="calibre12 pcalibre5 pcalibre6">package</code>声明语句开始，这个例子里就是<code class="calibre12 pcalibre5 pcalibre6">package main</code>, 表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p class="calibre6">Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如<code class="calibre12 pcalibre5 pcalibre6">fmt</code>包，就含有格式化输出、接收输入的函数。<code class="calibre12 pcalibre5 pcalibre6">Println</code>是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。</p>
<p class="calibre6"><code class="calibre12 pcalibre5 pcalibre6">main</code>包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在<code class="calibre12 pcalibre5 pcalibre6">main</code>里的<code class="calibre12 pcalibre5 pcalibre6">main</code> <em class="calibre13">函数</em> 也很特殊，它是整个程序执行时的入口<sup class="calibre17"><a id="reffn_7" href="#fn_7" class="pcalibre1 pcalibre2 pcalibre calibre7">7</a></sup>。<code class="calibre12 pcalibre5 pcalibre6">main</code>函数所做的事情就是程序做的。当然了，<code class="calibre12 pcalibre5 pcalibre6">main</code>函数一般调用其它包里的函数完成很多工作, 比如<code class="calibre12 pcalibre5 pcalibre6">fmt.Println</code>。</p>
<p class="calibre6">必须告诉编译器源文件需要哪些包，这就是<code class="calibre12 pcalibre5 pcalibre6">import</code>声明以及随后的<code class="calibre12 pcalibre5 pcalibre6">package</code>声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。</p>
<p class="calibre6">必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包<sup class="calibre17"><a id="reffn_8" href="#fn_8" class="pcalibre1 pcalibre2 pcalibre calibre7">8</a></sup>。</p>
<p class="calibre6"><code class="calibre12 pcalibre5 pcalibre6">import</code>声明必须跟在文件的<code class="calibre12 pcalibre5 pcalibre6">package</code>声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字<code class="calibre12 pcalibre5 pcalibre6">func</code>, <code class="calibre12 pcalibre5 pcalibre6">var</code>, <code class="calibre12 pcalibre5 pcalibre6">const</code>, <code class="calibre12 pcalibre5 pcalibre6">type</code>定义）。这些内容的声明顺序并不重要<sup class="calibre17"><a id="reffn_9" href="#fn_9" class="pcalibre1 pcalibre2 pcalibre calibre7">9</a></sup>。这个例子的程序已经尽可能短了，只声明了一个函数, 其中只调用了一个其他函数。为了节省篇幅，有些时候, 示例程序会省略<code class="calibre12 pcalibre5 pcalibre6">package</code>和<code class="calibre12 pcalibre5 pcalibre6">import</code>声明，但是，这些声明在源代码里有，并且必须得有才能编译。</p>
<p class="calibre6">一个函数的声明由<code class="calibre12 pcalibre5 pcalibre6">func</code>关键字、函数名、参数列表、返回值列表（这个例子里的<code class="calibre12 pcalibre5 pcalibre6">main</code>函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。</p>
<p class="calibre6">Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析<sup class="calibre17"><a id="reffn_10" href="#fn_10" class="pcalibre1 pcalibre2 pcalibre calibre7">10</a></sup>。。举个例子, 函数的左括号<code class="calibre12 pcalibre5 pcalibre6">{</code>必须和<code class="calibre12 pcalibre5 pcalibre6">func</code>函数声明在同一行上, 且位于末尾，不能独占一行，而在表达式<code class="calibre12 pcalibre5 pcalibre6">x + y</code>中，可在<code class="calibre12 pcalibre5 pcalibre6">+</code>后换行，不能在<code class="calibre12 pcalibre5 pcalibre6">+</code>前换行。</p>
<p class="calibre6">Go语言在代码格式上采取了很强硬的态度。<code class="calibre12 pcalibre5 pcalibre6">gofmt</code>工具把代码格式化为标准格式<sup class="calibre17"><a id="reffn_12" href="#fn_12" class="pcalibre1 pcalibre2 pcalibre calibre7">12</a></sup>，并且<code class="calibre12 pcalibre5 pcalibre6">go</code>工具中的<code class="calibre12 pcalibre5 pcalibre6">fmt</code>子命令会对指定包, 否则默认为当前目录, 中所有.go源文件应用<code class="calibre12 pcalibre5 pcalibre6">gofmt</code>命令。本书中的所有代码都被gofmt过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执<sup class="calibre17"><a id="reffn_13" href="#fn_13" class="pcalibre1 pcalibre2 pcalibre calibre7">13</a></sup>。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。</p>
<p class="calibre6">很多文本编辑器都可以配置为保存文件时自动执行<code class="calibre12 pcalibre5 pcalibre6">gofmt</code>，这样你的源代码总会被恰当地格式化。还有个相关的工具，<code class="calibre12 pcalibre5 pcalibre6">goimports</code>，可以根据代码需要, 自动地添加或删除<code class="calibre12 pcalibre5 pcalibre6">import</code>声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装：</p>
<pre class="calibre15"><code class="pcalibre8 calibre16 pcalibre7">$ go get golang.org/x/tools/cmd/goimports
</code></pre><p class="calibre6">对于大多数用户来说，下载、编译包、运行测试用例、察看Go语言的文档等等常用功能都可以用go的工具完成。10.7节详细介绍这些知识。</p>
<blockquote id="fn_1" class="calibre20">
<sup class="calibre17">1</sup>. 本书作者之一Brian W. Kernighan也是《The C Programming Language》一书的作者。<a title="Jump back to footnote [1] in the text." href="#reffn_1" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_2" class="calibre20">
<sup class="calibre17">2</sup>. 静态编译。<a title="Jump back to footnote [2] in the text." href="#reffn_2" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_3" class="calibre20">
<sup class="calibre17">3</sup>. Windows系统下生成的可执行文件是helloworld.exe，增加了.exe后缀名。<a title="Jump back to footnote [3] in the text." href="#reffn_3" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_4" class="calibre20">
<sup class="calibre17">4</sup>. 在Windows系统下在命令行直接输入helloworld.exe命令运行。<a title="Jump back to footnote [4] in the text." href="#reffn_4" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_5" class="calibre20">
<sup class="calibre17">5</sup>. 因为静态编译，所以不用担心在系统库更新的时候冲突，幸福感满满。<a title="Jump back to footnote [5] in the text." href="#reffn_5" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_6" class="calibre20">
<sup class="calibre17">6</sup>. 需要先安装Git或Hg之类的版本管理工具，并将对应的命令添加到PATH环境变量中。序言已经提及，需要先设置好GOPATH环境变量，下载的代码会放在<code class="calibre12 pcalibre5 pcalibre6">$GOPATH/src/gopl.io/ch1/helloworld</code>目录。<a title="Jump back to footnote [6] in the text." href="#reffn_6" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_7" class="calibre20">
<sup class="calibre17">7</sup>. C系语言差不多都这样。<a title="Jump back to footnote [7] in the text." href="#reffn_7" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_8" class="calibre20">
<sup class="calibre17">8</sup>. Go语言编译过程没有警告信息，争议特性之一。<a title="Jump back to footnote [8] in the text." href="#reffn_8" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_9" class="calibre20">
<sup class="calibre17">9</sup>. 最好还是定一下规范。<a title="Jump back to footnote [9] in the text." href="#reffn_9" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_10" class="calibre20">
<sup class="calibre17">10</sup>. 比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字<code class="calibre12 pcalibre5 pcalibre6">break</code>、<code class="calibre12 pcalibre5 pcalibre6">continue</code>、<code class="calibre12 pcalibre5 pcalibre6">fallthrough</code>或<code class="calibre12 pcalibre5 pcalibre6">return</code>中的一个、运算符和分隔符<code class="calibre12 pcalibre5 pcalibre6">++</code>、<code class="calibre12 pcalibre5 pcalibre6">--</code>、<code class="calibre12 pcalibre5 pcalibre6">)</code>、<code class="calibre12 pcalibre5 pcalibre6">]</code>或<code class="calibre12 pcalibre5 pcalibre6">}</code>中的一个。<a title="Jump back to footnote [10] in the text." href="#reffn_10" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_11" class="calibre20">
<sup class="calibre17">11</sup>. 以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误。<a title="Jump back to footnote [11] in the text." href="#reffn_11" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_12" class="calibre20">
<sup class="calibre17">12</sup>. 这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性。<a title="Jump back to footnote [12] in the text." href="#reffn_12" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>
<blockquote id="fn_13" class="calibre21">
<sup class="calibre17">13</sup>. 也导致了Go语言的TIOBE排名较低，因为缺少撕逼的话题。<a title="Jump back to footnote [13] in the text." href="#reffn_13" class="pcalibre1 pcalibre2 pcalibre calibre7"> ↩</a>
</blockquote>

            
            </div>
        
    
</div>

        
        
    
    

</body></html>
