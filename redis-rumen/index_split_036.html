<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Redis入门指南（第2版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<blockquote id="filepos455721" class="calibre_11"><a href="index_split_000.html#filepos20790"><span class="calibre2"><span class="bold"><span class="calibre_2">6.4 深入脚本</span></span></span></a></blockquote><p class="calibre_14">本节将深入探讨KEYS和ARGV两类参数的区别，以及脚本的沙盒限制和原子性等内容。</p><p id="filepos456035" class="calibre_6"><a href="index_split_000.html#filepos20982"><span class="calibre6"><span class="bold"><span class="calibre_2">6.4.1 KEYS与ARGV</span></span></span></a></p><p class="calibre_14">前面提到过向脚本传递的参数分为 KEYS 和 ARGV两类，前者表示要操作的键名，后者表示非键名参数。但事实上这一要求并不是强制的，比如 EVAL "return redis.call('get', KEYS[1])" 1 user:Bob 可以获得 user:Bob 的键值，同样还可以使用 EVAL "return redis.call('get', 'user:' .. ARGV[1])" 0 Bob 完成同样的功能，此时我们虽然并未按照 Redis 的规则使用 KEYS 参数传递键名，但还是获得了正确的结果。</p><p class="calibre_9">虽然规则不是强制的，但不遵守规则依然有一定的代价。Redis将要发布的3.0版本会带有集群（cluster）功能，集群的作用是将数据库中的键分散到不同的节点上。这意味着在脚本执行前就需要知道脚本会操作哪些键以便找到对应的节点，所以如果脚本中的键名没有使用KEYS参数传递则无法兼容集群。</p><p class="calibre_9">有时候键名是根据脚本某部分的执行结果生成的，这时就无法在执行前将键名明确标出。比如一个集合类型键存储了用户 ID 列表，每个用户使用散列键存储，其中有一个字段是年龄。下面的脚本可以计算某个集合中用户的平均年龄：</p><p class="calibre_9">local sum = 0</p><p class="calibre_9">local users = redis.call('SMEMBERS', KEYS[1])</p><p class="calibre_9">for _, user_id in ipairs(users) do</p><blockquote class="calibre_13">local user_age = redis.call('HGET', 'user:' .. user_id, 'age')</blockquote><blockquote class="calibre_13">sum = sum + user_age</blockquote><p class="calibre_9">end</p><p class="calibre_9">return sum / #users</p><p class="calibre_9">这个脚本同样无法兼容集群功能（因为第 4 行中访问了 KEYS 变量中没有的键），但却十分实用，避免了数据往返客户端和服务端的开销。为了兼容集群，可以在客户端获取集合中的用户ID列表，然后将用户ID组装成键名列表传给脚本并计算平均年龄。两种方案都是可行的，至于实际采用哪种就需要开发者自行权衡了。</p><p id="filepos458511" class="calibre_6"><a href="index_split_000.html#filepos21181"><span class="calibre6"><span class="bold"><span class="calibre_2">6.4.2 沙盒与随机数</span></span></span></a></p><p class="calibre_14">Redis 脚本禁止使用 Lua 标准库中与文件或系统调用相关的函数，在脚本中只允许对Redis的数据进行处理。并且Redis还通过禁用脚本的全局变量的方式保证每个脚本都是相对隔离的，不会互相干扰。</p><p class="calibre_9">使用沙盒不仅是为了保证服务器的安全性，而且还确保了脚本的执行结果只和脚本本身和执行时传递的参数有关，不依赖外界条件（如系统时间、系统中某个文件的内容、其他脚本执行结果等）。这是因为在执行复制和AOF持久化（复制和持久化会在第7章介绍）操作时记录的是脚本的内容而不是脚本调用的命令，所以必须保证在脚本内容和参数一样的前提下脚本的执行结果必须是一样的。</p><p class="calibre_9">除了使用沙盒外，为了确保执行的结果可以重现，Redis 还对随机数和会产生随机结果的命令进行了特殊的处理。</p><p class="calibre_9">对于随机数而言，Redis 替换了 math.random 和 math.randomseed 函数使得每次执行脚本时生成的随机数列都相同，如果希望获得不同的随机数序列，最简单的方法是由程序生成随机数并通过参数传递给脚本，或者采用更灵活的方法，即在程序中生成随机数传给脚本作为随机数种子（通过 math.randomseed(tonumber(ARGV[种子参数索引]))），这样在脚本中再调用math.random产生的随机数就不同了（由随机数种子决定）。</p><p class="calibre_9">对于会产生随机结果的命令如SMEMBERS（因为集合类型是无序的）或HKEYS（因为散列类型的字段也是无序的）等 Redis 会对结果按照字典顺序排序。内部是通过调用 Lua标准库的table.sort函数实现的，代码与下面这段很相似：</p><p class="calibre_9">function __redis__compare_helper(a,b)</p><blockquote class="calibre_13">if a == false then a = '' end</blockquote><blockquote class="calibre_13">if b == false then b = '' end</blockquote><blockquote class="calibre_13">return a &lt; b</blockquote><p class="calibre_9">end</p><p class="calibre_9">table.sort(result_array, __redis__compare_helper)</p><p class="calibre_9">对于会产生随机结果但无法排序的命令（比如只会产生一个元素），Redis会在这类命令执行后将该脚本状态标记为lua_random_dirty，此后只允许调用只读命令，不允许修改数据库的值，否则会返回错误：“Write commands not allowed after non deterministic commands.”属于此类的Redis命令有SPOP，SRANDMEMBER，RANDOMKEY和TIME。</p><p id="filepos461542" class="calibre_6"><a href="index_split_000.html#filepos21386"><span class="calibre6"><span class="bold"><span class="calibre_2">6.4.3 其他脚本相关命令</span></span></span></a></p><p class="calibre_14">除了EVAL和EVALSHA外，Redis还提供了其他4个脚本相关的命令，一般都会被客户端封装起来，开发者很少能使用到。</p><p class="calibre_9">1．将脚本加入缓存： <img src="images/00138.jpg" class="calibre_111"/></p><p class="calibre_9">每次执行EVAL命令时Redis都会将脚本的SHA1摘要加入到脚本缓存中，以便下次客户端可以使用EVALSHA命令调用该脚本。如果只是希望将脚本加入脚本缓存而不执行则可以使用 SCRIPT LOAD命令，返回值是脚本的SHA1摘要。就像这样：</p><p class="calibre_9">redis&gt; <img src="images/00007.jpg" class="calibre_112"/></p><p class="calibre_9">"e0e1f9fabfc9d4800c877a703b823ac0578ff8db"</p><p class="calibre_9">2．判断脚本是否已经被缓存： <img src="images/00017.jpg" class="calibre_113"/></p><p class="calibre_9">SCRIPT EXISTS命令可以同时查找1个或多个脚本的SHA1 摘要是否被缓存，如：</p><p class="calibre_9">redis&gt;<img src="images/00033.jpg" class="calibre_114"/>
<img src="images/00044.jpg" class="calibre_115"/></p><p class="calibre_9">1) (integer) 1</p><p class="calibre_9">2) (integer) 0</p><p class="calibre_9">3．清空脚本缓存： <img src="images/00054.jpg" class="calibre_116"/></p><p class="calibre_9">Redis 将脚本的 SHA1 摘要加入到脚本缓存后会永久保留，不会删除，但可以手动使用 SCRIPT FLUSH命令清空脚本缓存：</p><p class="calibre_9">redis&gt; <img src="images/00067.jpg" class="calibre_117"/></p><p class="calibre_9">OK</p><p class="calibre_9">4．强制终止当前脚本的执行： <img src="images/00082.jpg" class="calibre_111"/></p><p class="calibre_9">如果想终止当前正在执行的脚本可以使用 SCRIPT KILL命令，下节还会提到这个命令。</p><p id="filepos463998" class="calibre_6"><a href="index_split_000.html#filepos21591"><span class="calibre6"><span class="bold"><span class="calibre_2">6.4.4 原子性和执行时间</span></span></span></a></p><p class="calibre_14">Redis的脚本执行是原子的，即脚本执行期间Redis不会执行其他命令。所有的命令都必须等待脚本执行完成后才能执行。为了防止某个脚本执行时间过长导致 Redis 无法提供服务（比如陷入死循环），Redis提供了lua-time-limit参数限制脚本的最长运行时间，默认为5秒钟。当脚本运行时间超过这一限制后，Redis将开始接受其他命令但不会执行（以确保脚本的原子性，因为此时脚本并没有被终止），而是会返回“BUSY”错误。现在我们打开两个redis-cli实例A和B来演示这一情况。首先在A中执行一个死循环脚本：</p><p class="calibre_9">redis A&gt; <img src="images/00098.jpg" class="calibre_118"/></p><p class="calibre_9">然后马上在B中执行一条命令：</p><p class="calibre_9">redis B&gt; <img src="images/00113.jpg" class="calibre_119"/></p><p class="calibre_9">这时实例B中的命令并没有马上返回结果，因为Redis已经被实例A发送的死循环脚本阻塞了，无法执行其他命令。等到脚本执行5秒后实例B收到了“BUSY”错误：</p><p class="calibre_9">(error) BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN</p><p class="calibre_9">NOSAVE.</p><p class="calibre_9">(3.74s)</p><p class="calibre_9">此时 Redis 虽然可以接受任何命令，但实际会执行的只有两个命令：SCRIPT KILL 和SHUTDOWN NOSAVE。</p><p class="calibre_9">在实例B中执行 SCRIPT KILL命令可以终止当前脚本的运行：</p><p class="calibre_9">redis B&gt; <img src="images/00128.jpg" class="calibre_120"/></p><p class="calibre_9">OK</p><p class="calibre_9">此时脚本被终止并且实例A中会返回错误：</p><p class="calibre_9">(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7):</p><p class="calibre_9">Script killed by user with SCRIPT KILL...</p><p class="calibre_9">(28.77s)</p><p class="calibre_9">需要注意的是如果当前执行的脚本对 Redis 的数据进行了修改（如调用 SET、LPUSH 或DEL 等命令）则 SCRIPT KILL 命令不会终止脚本的运行以防止脚本只执行了一部分。因为如果脚本只执行了一部分就被终止，会违背脚本的原子性要求，即脚本中的所有命令要么都执行，要么都不执行。比如在实例A中执行：</p><p class="calibre_9">redis A&gt; <img src="images/00018.jpg" class="calibre_121"/></p><p class="calibre_9">5秒钟后在实例B中尝试终止该脚本：</p><p class="calibre_9">redis B&gt; <img src="images/00021.jpg" class="calibre_120"/></p><p class="calibre_9">(error) UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in an hard way using the SHUTDOWN NOSAVE command.</p><p class="calibre_9">这时只能通过 SHUTDOWN NOSAVE 命令强行终止 Redis。在第 2 章中我们介绍过使用SHUTDOWN命令退出Redis，而 SHUTDOWN NOSAVE命令与 SHUTDOWN命令的区别在于前者将不会进行持久化操作，这意味着所有发生在上一次快照（会在 7.1 节介绍）后的数据库修改都会丢失。</p><p class="calibre_9">由于 Redis 脚本非常高效，所以在大部分情况下都不用担心脚本的性能。但同时由于脚本的强大功能，很多原本在程序中执行的逻辑都可以放到脚本中执行，这时就需要开发者根据具体应用权衡到底哪些任务适合交给脚本。通常来讲不应该在脚本中进行大量耗时的计算，因为毕竟Redis是单进程单线程执行脚本，而程序却能够多进程或多线程运行。</p><p class="calibre_9"><span class="bold">注　释</span></p><p id="filepos468470" class="calibre_9"><a href="index_split_034.html#filepos402940"><span class="calibre7"><span class="calibre_2">[1]. http://www.lua.org</span></span></a></p><p id="filepos468612" class="calibre_9"><a href="index_split_034.html#filepos407296"><span class="calibre7"><span class="calibre_2">[2]. http://www.inf.puc-rio.br/~roberto</span></span></a></p><p id="filepos468770" class="calibre_9"><a href="index_split_034.html#filepos412409"><span class="calibre7"><span class="calibre_2">[3]. Lua 的表类型索引是从1开始的，后文会介绍。</span></span></a></p><p id="filepos468953" class="calibre_9"><a href="index_split_034.html#filepos422891"><span class="calibre7"><span class="calibre_2">[4]. 此处的数组指的是数组形式的表类型，即索引为从1 开始的递增整数。</span></span></a></p><p id="filepos469169" class="calibre_9"><a href="index_split_034.html#filepos429647"><span class="calibre7"><span class="calibre_2">[5]. http://www.lua.org/manual/5.1/manual.html#5</span></span></a></p><p id="filepos469336" class="calibre_9"><a href="index_split_034.html#filepos438407"><span class="calibre7"><span class="calibre_2">[6]. http://www.kyne.com.au/~mark/software/lua-cjson.php</span></span></a></p><p id="filepos469511" class="calibre_9"><a href="index_split_034.html#filepos438525"><span class="calibre7"><span class="calibre_2">[7]. cmsgpack库的作者正是Redis 的作者Salvatore Sanfilippo，其项目地址是https://github.com/antirez/lua-cmsgpack。</span></span></a></p><div class="mbp_pagebreak" id="calibre_pb_36"></div>
</body></html>
