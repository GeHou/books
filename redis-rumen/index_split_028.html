<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Redis入门指南（第2版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<blockquote id="filepos318797" class="calibre_11"><a href="index_split_000.html#filepos14609"><span class="calibre2"><span class="bold"><span class="calibre_2">5.1 PHP与Redis</span></span></span></a></blockquote><p class="calibre_14">Redis官方推荐的PHP客户端是Predis<sup class="calibre3"><small id="filepos319045" class="calibre4"><a href="index_split_031.html#filepos392735"><span class="calibre5"><span class="calibre_2">[1]</span></span></a></small></sup> 和phpredis<sup class="calibre3"><small id="filepos319160" class="calibre4"><a href="index_split_031.html#filepos392888"><span class="calibre5"><span class="calibre_2">[2]</span></span></a></small></sup> 。前者是完全使用PHP代码实现的原生客户端，而后者则是使用C语言编写的PHP扩展。在功能上两者区别并不大，就性能而言后者会更胜一筹。考虑到很多主机并未提供安装PHP扩展的权限，本节会以Predis为示例介绍如何在PHP中使用Redis。</p><p class="calibre_9">虽然Predis的性能逊于phpredis，但是除非执行大量Redis命令，否则很难区分二者的性能。而且实际应用中执行 Redis 命令的开销更多在网络传输上，单纯注重客户端的性能意义不大。读者在开发时可以根据自己的项目需要来权衡使用哪个客户端。</p><p class="calibre_9">Predis对PHP版本的最低要求为5.3。</p><p id="filepos320018" class="calibre_6"><a href="index_split_000.html#filepos14796"><span class="calibre6"><span class="bold"><span class="calibre_2">5.1.1 安装</span></span></span></a></p><p class="calibre_14">安装 Predis 可以克隆其版本库（git clone git://github.com/nrk/predis. git），也可以直接从GitHub项目主页中下载代码的ZIP压缩包。如目前最新版v1.0.1的下载地址为https://github.com/nrk/predis/archive/v1.0.1.zip。下载后解压并将整个文件夹复制到项目目录中即可使用。</p><p class="calibre_9">使用时首先需要引入autoload.php文件（这里假设该文件在 predis 文件夹中，以实际位置为准）：</p><p class="calibre_9">require './predis/autoload.php';</p><p class="calibre_9">Predis 使用了PHP 5.3 中的命名空间特性，并支持PSR-0 标准<sup class="calibre3"><small id="filepos320891" class="calibre4"><a href="index_split_031.html#filepos393049"><span class="calibre5"><span class="calibre_2">[3]</span></span></a></small></sup> 。autoload.php 文件通过定义PHP的自动加载函数实现了该标准，所以引入了autoload.php文件后就可以自动根据命名空间和类名来自动载入相应的文件了。例如：</p><p class="calibre_9">$redis = new Predis\Client();</p><p class="calibre_9">会自动加载Predis目录下的Client.php文件。如果你的项目使用的PHP框架已经支持了这一标准那么就无需再次引入autoload.php了。</p><p id="filepos321475" class="calibre_6"><a href="index_split_000.html#filepos14989"><span class="calibre6"><span class="bold"><span class="calibre_2">5.1.2 使用方法</span></span></span></a></p><p class="calibre_14">首先创建一个到Redis的连接：</p><p class="calibre_9">$redis = new Predis\Client();</p><p class="calibre_9">该行代码会默认Redis的地址为127.0.0.1，端口为6379。如果需要更改地址或端口，可以使用：</p><p class="calibre_9">$redis = new Predis\Client(array(</p><blockquote class="calibre_13">'scheme' =&gt; 'tcp',</blockquote><blockquote class="calibre_13">'host' =&gt; '127.0.0.1',</blockquote><blockquote class="calibre_13">'port' =&gt; 6379,</blockquote><p class="calibre_9">));</p><p class="calibre_9">作为开始，我们首先使用get命令作为测试：</p><p class="calibre_9">echo $redis-&gt;get('foo');</p><p class="calibre_9">该行代码获得了键名为 foo 的字符串类型键的值并输出出来，如果不存在则会返回NULL。</p><p class="calibre_9">当foo键的类型不是字符串类型（如列表类型）时会报异常，可以为该行代码加上异常处理：</p><p class="calibre_9">try {</p><blockquote class="calibre_13">echo $redis-&gt;get('foo');</blockquote><p class="calibre_9">} catch (Exception $e) {</p><blockquote class="calibre_13">echo "Message: {$e-&gt;getMessage()}";</blockquote><p class="calibre_9">}</p><p class="calibre_9">这时输出的内容为：“Message: ERR Operation against a key holding the wrong kind of value”。</p><p class="calibre_9">调用其他命令的方法和 GET命令一样，如要执行 LPUSH numbers 1 2 3：</p><p class="calibre_9">$redis-&gt;lpush('numbers', '1', '2', '3');</p><p id="filepos323539" class="calibre_6"><a href="index_split_000.html#filepos15182"><span class="calibre6"><span class="bold"><span class="calibre_2">5.1.3 简便用法</span></span></span></a></p><p class="calibre_14">为了使开发更方便，Predis 为许多命令额外提供了简便用法，这里选择几个典型的用法依次介绍。</p><p class="calibre_9">Predis调用MSET命令时支持将PHP的关联数组直接作为参数，就像这样：</p><p class="calibre_9">1．MGET/MSET</p><p class="calibre_9">$userName = array(</p><blockquote class="calibre_13">'user:1:name' =&gt; 'Tom',</blockquote><blockquote class="calibre_13">'user:2:name' =&gt; 'Jack'</blockquote><p class="calibre_9">);</p><p class="calibre_9">//相当于$redis-&gt;mset('user:1:name', 'Tom', 'user:2:name', 'Jack');</p><p class="calibre_9">$redis-&gt;mset($userName);</p><p class="calibre_9">同样MGET命令支持一个数组作为参数：</p><p class="calibre_9">$users = array_keys($userName);</p><p class="calibre_9">print_r($redis-&gt;mget($users));</p><p class="calibre_9">打印的结果为：</p><p class="calibre_9">Array</p><p class="calibre_9">(</p><blockquote class="calibre_13">[0] =&gt; Tom</blockquote><blockquote class="calibre_13">[1] =&gt; Jack</blockquote><p class="calibre_9">)</p><p class="calibre_9">2．HMSET/HMGET/HGETALL</p><p class="calibre_9">Predis调用HMSET的方式和MSET类似，如：</p><p class="calibre_9">$user1 = array(</p><blockquote class="calibre_13">'name' =&gt; 'Tom',</blockquote><blockquote class="calibre_13">'age' =&gt; '32'</blockquote><p class="calibre_9">);</p><p class="calibre_9">$redis-&gt;hmset('user:1', $user1);</p><p class="calibre_9">HMGET与MGET类似，不再赘述。最方便的是HGETALL命令，Predis会将Redis返回的结果组装成关联数组返回：</p><p class="calibre_9">$user = $redis-&gt;hgetall('user:1');</p><p class="calibre_9">echo $user['name']; // 'Tom'</p><p class="calibre_9">3．LPUSH/SADD/ZADD</p><p class="calibre_9">LPUSH和SADD的调用方式类似：</p><p class="calibre_9">$items = array('a', 'b');</p><p class="calibre_9">//相当于$redis-&gt;lpush('list', 'a', 'b');</p><p class="calibre_9">$redis-&gt;lpush('list', $items);</p><p class="calibre_9">//相当于$redis-&gt;sadd('set', 'a', 'b');</p><p class="calibre_9">$redis-&gt;sadd('set', $items);</p><p class="calibre_9">而ZADD的调用方式为：</p><p class="calibre_9">$itemScore = array(</p><blockquote class="calibre_13">'Tom' =&gt; '100',</blockquote><blockquote class="calibre_13">'Jack' =&gt; '89'</blockquote><p class="calibre_9">);</p><p class="calibre_9">//相当于$redis-&gt;zadd('zset', '100', 'Tom', '89', 'Jack');</p><p class="calibre_9">$redis-&gt;zadd('zset', $itemScore);</p><p class="calibre_9">4．SORT</p><p class="calibre_9">在Predis中调用SORT命令的方式和其他命令不同，必须将SORT命令中除键名外的其他参数作为关联数组传入到函数中。如对 SORT mylist BY weight_* LIMIT 0 10 GETvalue_* GET # ASC ALPHA STORE result这条命令而言，使用Predis的调用方法如下：</p><p class="calibre_9">$redis-&gt;sort('mylist', array(</p><blockquote class="calibre_13">'by' =&gt; 'weight_*',</blockquote><blockquote class="calibre_13">'limit' =&gt; array(0, 10),</blockquote><blockquote class="calibre_13">'get' =&gt; array('value_*', '#'),</blockquote><blockquote class="calibre_13">'sort' =&gt; 'asc',</blockquote><blockquote class="calibre_13">'alpha' =&gt; true,</blockquote><blockquote class="calibre_13">'store' =&gt; 'result'</blockquote><p class="calibre_9">));</p><p id="filepos328086" class="calibre_6"><a href="index_split_000.html#filepos15396"><span class="calibre6"><span class="bold"><span class="calibre_2">5.1.4 实践：用户注册登录功能</span></span></span></a></p><p class="calibre_14">本节将使用PHP和Redis实现用户注册与登录功能，下面分模块来介绍具体实现方法。</p><p class="calibre_9">1．注册</p><p class="calibre_9">需求描述：用户注册时需要提交邮箱、登录密码和昵称。其中邮箱是用户的唯一标识，每个用户的邮箱不能重复，但允许用户修改自己的邮箱。</p><p class="calibre_9">我们使用散列类型来存储用户的资料，键名为“user:用户ID”。其中用户ID是一个自增的数字，之所以使用 ID 而不是邮箱作为用户的标识是因为考虑到在其他键中可能会通过用户的标识与用户对象相关联，如果使用邮箱作为用户的标识的话在用户修改邮箱时就不得不同时需要修改大量的键名或键值。为了尽可能地减少要修改的地方，我们只把邮箱作为该散列键的一个字段。为此还需要使用一个散列类型的键 email.to.id 来记录邮箱和用户ID间的对应关系以便在登录时能够通过邮箱获得用户的ID。</p><p class="calibre_9">用户填写并提交注册表单后首先需要验证用户输入，我们在项目目录中建立一个register.php文件来实现用户注册的逻辑。验证部分的代码如下：</p><p class="calibre_9">//设置 Content-type 以使浏览器可以使用正确的编码显示提示信息，</p><p class="calibre_9">//具体的编码需要根据文件实际编码选择，此处是 utf-8。</p><p class="calibre_9">header("Content-type: text/html; charset=utf-8");</p><p class="calibre_9">if(!isset($_POST['email']) ||</p><blockquote class="calibre_13">!isset($_POST['password']) ||</blockquote><blockquote class="calibre_13">!isset($_POST['nickname'])) {</blockquote><blockquote class="calibre_13">echo '请填写完整的信息。';</blockquote><blockquote class="calibre_13">exit;</blockquote><p class="calibre_9">}</p><p class="calibre_9">$email = $_POST['email'];</p><p class="calibre_9">//验证用户提交的邮箱是否正确</p><p class="calibre_9">if(!filter_var($email, FILTER_VALIDATE_EMAIL)) {</p><blockquote class="calibre_13">echo '邮箱格式不正确，请重新检查';</blockquote><blockquote class="calibre_13">exit;</blockquote><p class="calibre_9">}</p><p class="calibre_9">$rawPassword = $_POST['password'];</p><p class="calibre_9">//验证用户提交的密码是否安全</p><p class="calibre_9">if(strlen($rawPassword) &lt; 6) {</p><blockquote class="calibre_13">echo '为了保证安全，密码长度至少为 6。';</blockquote><blockquote class="calibre_13">exit;</blockquote><p class="calibre_9">}</p><p class="calibre_9">$nickname = $_POST['nickname'];</p><p class="calibre_9">//对不同的网站用户昵称有不同的要求，这里不再做检查，即使是空也可以。</p><p class="calibre_9">//而后我们需要判断用户提交的邮箱是否被注册了：</p><p class="calibre_9">$redis = new Predis\Client();</p><p class="calibre_9">if($redis-&gt;hexists('email.to.id', $email)) {</p><blockquote class="calibre_13">echo '该邮箱已经被注册过了。';</blockquote><blockquote class="calibre_13">exit;</blockquote><p class="calibre_9">}</p><p class="calibre_9">验证通过后接下来就需要将用户资料存入 Redis 中。在存储的时候要记住使用散列函数处理用户提交的密码，避免在数据库中存储明文密码。原因是如果数据库中数据泄露（外部原因或内部原因都有可能），攻击者也无法获得用户的真实密码，也便无法正常地登录进系统。更重要的是考虑到用户很可能在其他网站中也使用了同样的密码，所以明文密码泄露还会给用户造成额外的损失。</p><p class="calibre_9">除此之外，还要避免使用速度较快的散列函数处理密码以防止攻击者使用穷举法破解密码，并且需要为每个用户生成一个随机的“盐”（salt）以避免攻击者使用彩虹表破解。这里作为示例，我们使用 Bcrypt 算法来对密码进行散列。PHP 5.3 中提供的 crypt函数支持Bcrypt算法，我们可以实现一个函数来随机生成盐并调用crypt函数获得散列后的密码：</p><p class="calibre_9">function bcryptHash($rawPassword, $round = 8)</p><p class="calibre_9">{</p><blockquote class="calibre_13">if ($round &lt; 4 || $round &gt; 31) $round = 8;</blockquote><blockquote class="calibre_13">$salt = '$2a$' . str_pad($round, 2, '0', STR_PAD_LEFT) . '$';</blockquote><blockquote class="calibre_13">$randomValue = openssl_random_pseudo_bytes(16);</blockquote><blockquote class="calibre_13">$salt .= substr(strtr(base64_encode($randomValue), '+', '.'), 0, 22);</blockquote><blockquote class="calibre_13">return crypt($rawPassword, $salt);</blockquote><p class="calibre_9">}</p><p class="calibre_9">提示 openssl_random_pseudo_bytes函数需要安装OpenSSL扩展。</p><p class="calibre_9">之后使用如下代码获得散列后的密码：</p><p class="calibre_9">$hashedPassword = bcryptHash($rawPassword);</p><p class="calibre_9">存储用户资料就很简单了，所有命令都在第3章介绍过了。代码如下：</p><p class="calibre_9">require './predis/autoload.php';</p><p class="calibre_9">$redis = new Predis\Client();</p><p class="calibre_9">//首先获取一个自增的用户 ID</p><p class="calibre_9">$userID = $redis-&gt;incr('users:count');</p><p class="calibre_9">//存储用户信息</p><p class="calibre_9">$redis-&gt;hmset("user:{$userID}", array(</p><blockquote class="calibre_13">'email'　=&gt; $email,</blockquote><blockquote class="calibre_13">'password'　=&gt; $hashedPassword,</blockquote><blockquote class="calibre_13">'nickname'　=&gt; $nickname</blockquote><p class="calibre_9">));</p><p class="calibre_9">//记得记录下邮箱和用户 ID 的对应关系</p><p class="calibre_9">$redis-&gt;hset('email.to.id', $email, $userID);</p><p class="calibre_9">//提示用户注册成功</p><p class="calibre_9">echo '注册成功！';</p><p class="calibre_9">大部分情况下在注册时我们需要验证用户的邮箱，不过这部分的逻辑与忘记密码部分相似，所以在这里不做更多的介绍。</p><p class="calibre_9">2．登录</p><p class="calibre_9">需求描述：用户登录时需要提交邮箱和登录密码，如果正确则输出“登录成功”，否则输出“用户名或密码错误”。</p><p class="calibre_9">当用户提交邮箱和登录密码后首先通过email.to.id键获得用户ID，然后将用户提交的登录密码使用同样的盐进行散列并与数据库存储的密码比对，如果一样则表示登录成功。我们新建一个login.php文件来处理用户的登录，处理该逻辑的部分代码如下：</p><p class="calibre_9">header("Content-type: text/html; charset=utf-8");</p><p class="calibre_9">if(!isset($_POST['email']) ||</p><blockquote class="calibre_13">!isset($_POST['password'])) {</blockquote><blockquote class="calibre_13">echo '请填写完整的信息。';</blockquote><blockquote class="calibre_13">exit;</blockquote><p class="calibre_9">}</p><p class="calibre_9">$email = $_POST['email'];</p><p class="calibre_9">$rawPassword = $_POST['password'];</p><p class="calibre_9">require './predis/autoload.php';</p><p class="calibre_9">$redis = new Predis\Client();</p><p class="calibre_9">//获得用户的 ID</p><p class="calibre_9">$userID = $redis-&gt;hget('email.to.id', $email);</p><p class="calibre_9">if(!$userID) {</p><blockquote class="calibre_13">echo '用户名或密码错误。';</blockquote><p class="calibre_9">exit;</p><p class="calibre_9">}</p><p class="calibre_9">$hashedPassword = $redis-&gt;hget("user:{$userID}", 'password');</p><p class="calibre_9">现在我们得到了之前存储过的经过散列后的密码，接着定义一个函数来对用户提交的密码进行散列处理。bcryptHash函数中返回的密码中已经包含了盐，所以只需要直接将散列后的密码作为crypt函数的第二个参数，crypt函数会自动地提取出密码中的盐：</p><p class="calibre_9">function bcryptVerify($rawPassword, $storedHash)</p><p class="calibre_9">{</p><blockquote class="calibre_13">return crypt($rawPassword, $storedHash) == $storedHash;</blockquote><p class="calibre_9">}</p><p class="calibre_9">之后就可以使用此函数进行比对了：</p><p class="calibre_9">if(!bcryptVerify($rawPassword, $hashedPassword)) {</p><blockquote class="calibre_13">echo '用户名或密码错误。';</blockquote><p class="calibre_9">exit;</p><p class="calibre_9">}</p><p class="calibre_9">echo '登录成功！';</p><p class="calibre_9">3．忘记密码</p><p class="calibre_9">需求描述：当用户忘记密码时可以输入自己的邮箱，系统会发送一封包含更改密码的链接的邮件，用户单击该链接后会进入密码修改页面。该模块的访问频率限制为1分钟10次以防止恶意用户通过此模块向某个邮箱地址大量发送垃圾邮件。</p><p class="calibre_9">当用户在忘记密码的页面输入邮箱后，我们的程序需要做两件事。</p><p class="calibre_9">（1）进行访问频率限制。这里使用4.2.3节介绍的方法以邮箱为标识符对发送修改密码邮件的过程进行访问频率限制。当用户提交了邮箱地址后首先验证邮箱地址是否正确，如果正确则检查访问频率是否超限：</p><p class="calibre_9">$keyName = "rate.limiting:{$email}";</p><p class="calibre_9">$now = time();</p><p class="calibre_9">if($redis-&gt;llen($keyName) &lt; 10) {</p><blockquote class="calibre_13">$redis-&gt;lpush($keyName, $now);</blockquote><p class="calibre_9">} else {</p><blockquote class="calibre_13">$time = $redis-&gt;lindex($keyName, -1);</blockquote><blockquote class="calibre_13">if($now - $time &lt; 60) {</blockquote><blockquote class="calibre_13">echo '访问频率超过了限制，请稍后再试。';</blockquote><blockquote class="calibre_13">exit;</blockquote><blockquote class="calibre_13">} else {</blockquote><blockquote class="calibre_13">$redis-&gt;lpush($keyName, $now);</blockquote><blockquote class="calibre_13">$redis-&gt;ltrim($keyName, 0, 9);</blockquote><blockquote class="calibre_13">}</blockquote><p class="calibre_9">}</p><p class="calibre_9">一般在全站中还会有针对IP地址的访问频率限制，原理与此类似。</p><p class="calibre_9">（2）发送修改密码邮件。用户通过访问频率限制后我们会为其生成一个随机的验证码，并将验证码通过邮件发送给用户。同时在程序中要把用户的邮箱地址存入名为retrieve.password.code:散列后的验证码的字符串类型键中，然后使用EXPIRE命令为其设置一个生存时间（如1个小时）以提供安全性并且保证及时释放存储空间。由于忘记密码需要的安全等级与用户注册登录相同，所以我们依然使用Bcrypt算法来对验证码进行散列，具体的算法同上这里不再详述。</p><div class="mbp_pagebreak" id="calibre_pb_28"></div>
</body></html>
