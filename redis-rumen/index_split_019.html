<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Redis入门指南（第2版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<blockquote id="filepos187663" class="calibre_11"><a href="index_split_000.html#filepos8494"><span class="calibre2"><span class="bold"><span class="calibre_2">3.6 有序集合类型</span></span></span></a></blockquote><p class="calibre_14">了解了集合类型后，小白终于被 Redis 的强大功能所折服了，但他却不愿止步于此。这不，小白又想给博客加上按照文章访问量排序的功能：</p><p class="calibre_9">老师您好，之前您已经介绍过了如何使用列表类型键存储文章 ID 列表，不过我还想加上按照文章访问量排序的功能，因为我觉得很多访客更希望看那些热门的文章。</p><p class="calibre_9">宋老师回答到：</p><p class="calibre_9">这个功能很好实现，不过要用到一个新的数据类型，也是我要介绍的最后一个数据类型——有序集合。</p><p id="filepos188568" class="calibre_6"><a href="index_split_000.html#filepos8681"><span class="calibre6"><span class="bold"><span class="calibre_2">3.6.1 介绍</span></span></span></a></p><p class="calibre_14">有序集合类型（sorted set）的特点从它的名字中就可以猜到，它与上一节介绍的集合类型的区别就是“有序”二字。</p><p class="calibre_9">在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是它们的分数却可以相同。</p><p class="calibre_9">有序集合类型在某些方面和列表类型有些相似。</p><p class="calibre_9">（1）二者都是有序的。</p><p class="calibre_9">（2）二者都可以获得某一范围的元素。</p><p class="calibre_9">但是二者有着很大的区别，这使得它们的应用场景也是不同的。</p><p class="calibre_9">（1）列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。</p><p class="calibre_9">（2）有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度是O(log(N))）。</p><p class="calibre_9">（3）列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。</p><p class="calibre_9">（4）有序集合要比列表类型更耗费内存。</p><p class="calibre_9">有序集合类型算得上是Redis的5种数据类型中最高级的类型了，在学习时可以与列表类型和集合类型对照理解。</p><p id="filepos190759" class="calibre_6"><a href="index_split_000.html#filepos8868"><span class="calibre6"><span class="bold"><span class="calibre_2">3.6.2 命令</span></span></span></a></p><p class="calibre_14">1．增加元素</p><p class="calibre_9">ZADD key score member [score member …]</p><p class="calibre_9">ZADD 命令用来向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。ZADD命令的返回值是新加入到集合中的元素个数（不包含之前已经存在的元素）。</p><p class="calibre_9">假设我们用有序集合模拟计分板，现在要记录Tom、Peter和David三名运动员的分数（分别是89分、67分和100分）：</p><p class="calibre_9">redis&gt; ZADD scoreboard 89 Tom 67 Peter 100 David</p><p class="calibre_9">(integer) 3</p><p class="calibre_9">这时我们发现Peter的分数录入有误，实际的分数应该是76分，可以用ZADD命令修改Peter的分数：</p><p class="calibre_9">redis&gt; ZADD scoreboard 76 Peter</p><p class="calibre_9">(integer) 0</p><p class="calibre_9">分数不仅可以是整数，还支持双精度浮点数：</p><p class="calibre_9">redis&gt; ZADD testboard 17E+307 a</p><p class="calibre_9">(integer) 1</p><p class="calibre_9">redis&gt; ZADD testboard 1.5 b</p><p class="calibre_9">(integer) 1</p><p class="calibre_9">redis&gt; ZADD testboard +inf c</p><p class="calibre_9">(integer) 1</p><p class="calibre_9">redis&gt; ZADD testboard -inf d</p><p class="calibre_9">(integer) 1</p><p class="calibre_9">其中+inf和-inf分别表示正无穷和负无穷。</p><p class="calibre_9">2．获得元素的分数</p><p class="calibre_9">ZSCORE key member</p><p class="calibre_9">示例如下：</p><p class="calibre_9">redis&gt; ZSCORE scoreboard Tom</p><p class="calibre_9">"89"</p><p class="calibre_9">3．获得排名在某个范围的元素列表</p><p class="calibre_9">ZRANGE key start stop [WITHSCORES]</p><p class="calibre_9">ZREVRANGE key start stop [WITHSCORES]</p><p class="calibre_9">ZRANGE命令会按照元素分数从小到大的顺序返回索引从 start到stop之间的所有元素（包含两端的元素）。ZRANGE命令与LRANGE命令十分相似，如索引都是从0开始，负数代表从后向前查找（−1表示最后一个元素）。就像这样：</p><p class="calibre_9">redis&gt; ZRANGE scoreboard 0 2</p><p class="calibre_9">1) "Peter"</p><p class="calibre_9">2) "Tom"</p><p class="calibre_9">3) "David"</p><p class="calibre_9">redis&gt; ZRANGE scoreboard 1 -1</p><p class="calibre_9">1) "Tom"</p><p class="calibre_9">2) "David"</p><p class="calibre_9">如果需要同时获得元素的分数的话可以在 ZRANGE 命令的尾部加上 WITHSCORES 参数，这时返回的数据格式就从“元素1, 元素2, „, 元素n”变为了“元素1, 分数1, 元素2, 分数2, „, 元素n, 分数n”，例如：</p><p class="calibre_9">redis&gt; ZRANGE scoreboard 0 -1 WITHSCORES</p><p class="calibre_9">1) "Peter"</p><p class="calibre_9">2) "76"</p><p class="calibre_9">3) "Tom"</p><p class="calibre_9">4) "89"</p><p class="calibre_9">5) "David"</p><p class="calibre_9">6) "100"</p><p class="calibre_9">ZRANGE命令的时间复杂度为O(log n+m)（其中n为有序集合的基数，m为返回的元素个数）。</p><p class="calibre_9">如果两个元素的分数相同，Redis会按照字典顺序（即"0"&lt;"9"&lt;"A"&lt;"Z"&lt;"a"&lt;"z"这样的顺序）来进行排列。再进一步，如果元素的值是中文怎么处理呢？答案是取决于中文的编码方式，如使用UTF-8编码：</p><p class="calibre_9">redis&gt; ZADD chineseName 0 马华 0 刘墉 0 司马光 0 赵哲</p><p class="calibre_9">(integer) 4</p><p class="calibre_9">redis&gt; ZRANGE chineseName 0 -1</p><p class="calibre_9">1) "\xe5\x88\x98\xe5\xa2\x89"</p><p class="calibre_9">2) "\xe5\x8f\xb8\xe9\xa9\xac\xe5\x85\x89"</p><p class="calibre_9">3) "\xe8\xb5\xb5\xe5\x93\xb2"</p><p class="calibre_9">4) "\xe9\xa9\xac\xe5\x8d\x8e"</p><p class="calibre_9">可见此时Redis依然按照字典顺序排列这些元素。</p><p class="calibre_9">ZREVRANGE命令和ZRANGE的唯一不同在于ZREVRANGE命令是按照元素分数从大到小的顺序给出结果的。</p><p class="calibre_9">4．获得指定分数范围的元素</p><p class="calibre_9">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p><p class="calibre_9">ZRANGEBYSCORE 命令参数虽然多，但是都很好理解。该命令按照元素分数从小到大的顺序返回分数在min和max之间（包含min和max）的元素：</p><p class="calibre_9">redis&gt; ZRANGEBYSCORE scoreboard 80 100</p><p class="calibre_9">1) "Tom"</p><p class="calibre_9">2) "David"</p><p class="calibre_9">如果希望分数范围不包含端点值，可以在分数前加上“(”符号。例如，希望返回”80分到100分的数据，可以含80分，但不包含100分，则稍微修改一下上面的命令即可：</p><p class="calibre_9">redis&gt; ZRANGEBYSCORE scoreboard 80 (100</p><p class="calibre_9">1) "Tom"</p><p class="calibre_9">min和max还支持无穷大，同ZADD命令一样，-inf和+inf分别表示负无穷和正无穷。比如你希望得到所有分数高于80分（不包含80分）的人的名单，但你却不知道最高分是多少（虽然有些背离现实，但是为了叙述方便，这里假设可以获得的分数是无上限的），这时就可以用上+inf了：</p><p class="calibre_9">redis&gt; ZRANGEBYSCORE scoreboard (80 +inf</p><p class="calibre_9">1) "Tom"</p><p class="calibre_9">2) "David"</p><p class="calibre_9">WITHSCORES参数的用法与ZRANGE命令一样，不再赘述。</p><p class="calibre_9">了解 SQL 语句的读者对 LIMIT offset count 应该很熟悉，在本命令中 LIMIT offset count 与 SQL 中的用法基本相同，即在获得的元素列表的基础上向后偏移offset个元素，并且只获取前count个元素。为了便于演示，我们先向scoreboard键中再增加些元素：</p><p class="calibre_9">redis&gt; ZADD scoreboard 56 Jerry 92 Wendy 67 Yvonne</p><p class="calibre_9">(integer) 3</p><p class="calibre_9">现在scoreboard键中的所有元素为：</p><p class="calibre_9">redis&gt; ZRANGE scoreboard 0 -1 WITHSCORES</p><p class="calibre_9">1) "Jerry"</p><p class="calibre_9">2) "56"</p><p class="calibre_9">3) "Yvonne"</p><p class="calibre_9">4) "67"</p><p class="calibre_9">5) "Peter"</p><p class="calibre_9">6) "76"</p><p class="calibre_9">7) "Tom"</p><p class="calibre_9">8) "89"</p><p class="calibre_9">9) "Wendy"</p><p class="calibre_9">10) "92"</p><p class="calibre_9">11) "David"</p><p class="calibre_9">12) "100"</p><p class="calibre_9">想获得分数高于60分的从第二个人开始的3个人：</p><p class="calibre_9">redis&gt; ZRANGEBYSCORE scoreboard 60 +inf LIMIT 1 3</p><p class="calibre_9">1) "Peter"</p><p class="calibre_9">2) "Tom"</p><p class="calibre_9">3) "Wendy"</p><p class="calibre_9">那么，如果想获取分数低于或等于 100 分的前 3 个人怎么办呢？这时可以借助ZREVRANGEBYSCORE命令实现。对照前文提到的ZRANGE命令和ZREVRANGE命令之间的关系，相信读者很容易能明白 ZREVRANGEBYSCORE 命令的功能。需要注意的是ZREVRANGEBYSCORE 命令不仅是按照元素分数从大往小的顺序给出结果的，而且它的 min和max参数的顺序和ZRANGEBYSCORE命令是相反的。就像这样：</p><p class="calibre_9">redis&gt; ZREVRANGEBYSCORE scoreboard 100 0 LIMIT 0 3</p><p class="calibre_9">1) "David"</p><p class="calibre_9">2) "Wendy"</p><p class="calibre_9">3) "Tom"</p><p class="calibre_9">5．增加某个元素的分数</p><p class="calibre_9">ZINCRBY key increment member</p><p class="calibre_9">ZINCRBY 命令可以增加一个元素的分数，返回值是更改后的分数。例如，想给 Jerry加4分：</p><p class="calibre_9">redis&gt; ZINCRBY scoreboard 4 Jerry</p><p class="calibre_9">"60"</p><p class="calibre_9">increment也可以是个负数表示减分，例如，给Jerry减4分：</p><p class="calibre_9">redis&gt; ZINCRBY scoreboard -4 Jerry</p><p class="calibre_9">"56"</p><p class="calibre_9">如果指定的元素不存在，Redis 在执行命令前会先建立它并将它的分数赋为 0 再执行操作。</p><p id="filepos201070" class="calibre_6"><a href="index_split_000.html#filepos9055"><span class="calibre6"><span class="bold"><span class="calibre_2">3.6.3 实践</span></span></span></a></p><p class="calibre_14">1．实现按点击量排序</p><p class="calibre_9">要按照文章的点击量排序，就必须再额外使用一个有序集合类型的键来实现。在这个键中以文章的 ID 作为元素，以该文章的点击量作为该元素的分数。将该键命名为posts:page.view，每次用户访问一篇文章时，博客程序就通过 ZINCRBY posts:page. view 1 文章 ID更新访问量。</p><p class="calibre_9">需要按照点击量的顺序显示文章列表时，有序集合的用法与列表的用法大同小异：</p><p class="calibre_9">$postsPerPage = 10</p><p class="calibre_9">$start = ($currentPage - 1) * $postsPerPage</p><p class="calibre_9">$end = $currentPage * $postsPerPage - 1</p><p class="calibre_9">$postsID = ZREVRANGE posts:page.view, $start，$end</p><p class="calibre_9">for each $id in $postsID</p><blockquote class="calibre_13">$postData = HGETALL post:$id</blockquote><blockquote class="calibre_13">print 文章标题：$postData.title</blockquote><p class="calibre_9">另外3.2节介绍过使用字符串类型键post:文章ID:page.view来记录单个文章的访问量，现在这个键已经不需要了，想要获得某篇文章的访问量可以通过 ZSCORE posts:page. view 文章ID 来实现。</p><p class="calibre_9">2．改进按时间排序</p><p class="calibre_9">3.4节介绍了每次发布新文章时都将文章的ID加入到名为posts:list的列表类型键中来获得按照时间顺序排列的文章列表，但是由于列表类型更改元素的顺序比较麻烦，而如今不少博客系统都支持更改文章的发布时间，为了让小白的博客同样支持该功能，我们需要一个新的方案来实现按照时间顺序排列文章的功能。</p><p class="calibre_9">为了能够自由地更改文章发布时间，可以采用有序集合类型代替列表类型。自然地，元素仍然是文章的ID，而此时元素的分数则是文章发布的Unix时间<sup class="calibre3"><small id="filepos203461" class="calibre4"><a href="#filepos214779"><span class="calibre5"><span class="calibre_2">[14]</span></span></a></small></sup> 。通过修改元素对应的分数就可以达到更改时间的目的。</p><p class="calibre_9">另外借助 ZREVRANGEBYSCORE 命令还可以轻松获得指定时间范围的文章列表，借助这个功能可以实现类似WordPress的按月份查看文章的功能。</p><p id="filepos203859" class="calibre_6"><a href="index_split_000.html#filepos9248"><span class="calibre6"><span class="bold"><span class="calibre_2">3.6.4 命令拾遗</span></span></span></a></p><p class="calibre_14">1．获得集合中元素的数量</p><p class="calibre_9">ZCARD key</p><p class="calibre_9">例如：</p><p class="calibre_9">redis&gt; ZCARD scoreboard</p><p class="calibre_9">(integer) 6</p><p class="calibre_9">2．获得指定分数范围内的元素个数</p><p class="calibre_9">ZCOUNT key min max</p><p class="calibre_9">例如：</p><p class="calibre_9">redis&gt; ZCOUNT scoreboard 90 100</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">ZCOUNT命令的min和max参数的特性与ZRANGEBYSCORE命令中的一样：</p><p class="calibre_9">redis&gt; ZCOUNT scoreboard (89 +inf</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">3．删除一个或多个元素</p><p class="calibre_9">ZREM key member [member …]</p><p class="calibre_9">ZREM命令的返回值是成功删除的元素数量（不包含本来就不存在的元素）。</p><p class="calibre_9">redis&gt; ZREM scoreboard Wendy</p><p class="calibre_9">(integer) 1</p><p class="calibre_9">redis&gt; ZCARD scoreboard</p><p class="calibre_9">(integer) 5</p><p class="calibre_9">4．按照排名范围删除元素</p><p class="calibre_9">ZREMRANGEBYRANK key start stop</p><p class="calibre_9">ZREMRANGEBYRANK 命令按照元素分数从小到大的顺序（即索引 0表示最小的值）删除处在指定排名范围内的所有元素，并返回删除的元素数量。如：</p><p class="calibre_9">redis&gt; ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f</p><p class="calibre_9">(integer) 6</p><p class="calibre_9">redis&gt; ZREMRANGEBYRANK testRem 0 2</p><p class="calibre_9">(integer) 3</p><p class="calibre_9">redis&gt; ZRANGE testRem 0 -1</p><p class="calibre_9">1) "d"</p><p class="calibre_9">2) "e"</p><p class="calibre_9">3) "f"</p><p class="calibre_9">5．按照分数范围删除元素</p><p class="calibre_9">ZREMRANGEBYSCORE key min max</p><p class="calibre_9">ZREMRANGEBYSCORE命令会删除指定分数范围内的所有元素，参数min和max的特性和ZRANGEBYSCORE命令中的一样。返回值是删除的元素数量。如：</p><p class="calibre_9">redis&gt; ZREMRANGEBYSCORE testRem (4 5</p><p class="calibre_9">(integer) 1</p><p class="calibre_9">redis&gt; ZRANGE testRem 0 -1</p><p class="calibre_9">1) "d"</p><p class="calibre_9">2) "f"</p><p class="calibre_9">6．获得元素的排名</p><p class="calibre_9">ZRANK key member</p><p class="calibre_9">ZREVRANK key member</p><p class="calibre_9">ZRANK命令会按照元素分数从小到大的顺序获得指定的元素的排名（从0开始，即分数最小的元素排名为0）。如：</p><p class="calibre_9">redis&gt; ZRANK scoreboard Peter</p><p class="calibre_9">(integer) 0</p><p class="calibre_9">ZREVRANK命令则相反（分数最大的元素排名为0）：</p><p class="calibre_9">redis&gt; ZREVRANK scoreboard Peter</p><p class="calibre_9">(integer) 4</p><p class="calibre_9">7．计算有序集合的交集</p><p class="calibre_9">ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE</p><p class="calibre_9">SUM|MIN|MAX]</p><p class="calibre_9">ZINTERSTORE命令用来计算多个有序集合的交集并将结果存储在destination键中（同样以有序集合类型存储），返回值为destination键中的元素个数。</p><p class="calibre_9">destination键中元素的分数是由AGGREGATE参数决定的。</p><p class="calibre_9">（1）当AGGREGATE是SUM时（也就是默认值），destination键中元素的分数是每个参与计算的集合中该元素分数的和。例如：</p><p class="calibre_9">redis&gt; ZADD sortedSets1 1 a 2 b</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">redis&gt; ZADD sortedSets2 10 a 20 b</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES</p><p class="calibre_9">1) "a"</p><p class="calibre_9">2) "11"</p><p class="calibre_9">3) "b"</p><p class="calibre_9">4) "22"</p><p class="calibre_9">（2）当AGGREGATE是MIN时，destination键中元素的分数是每个参与计算的集合中该元素分数的最小值。例如：</p><p class="calibre_9">redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MIN</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES</p><p class="calibre_9">1) "a"</p><p class="calibre_9">2) "1"</p><p class="calibre_9">3) "b"</p><p class="calibre_9">4) "2"</p><p class="calibre_9">（3）当AGGREGATE是MAX时，destination键中元素的分数是每个参与计算的集合中该元素分数的最大值。例如：</p><p class="calibre_9">redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MAX</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES</p><p class="calibre_9">1) "a"</p><p class="calibre_9">2) "10"</p><p class="calibre_9">3) "b"</p><p class="calibre_9">4) "20"</p><p class="calibre_9">ZINTERSTORE命令还能够通过WEIGHTS参数设置每个集合的权重，每个集合在参与计算时元素的分数会被乘上该集合的权重。例如：</p><p class="calibre_9">redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 WEIGHTS 1 0.1</p><p class="calibre_9">(integer) 2</p><p class="calibre_9">redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES</p><p class="calibre_9">1) "a"</p><p class="calibre_9">2) "2"</p><p class="calibre_9">3) "b"</p><p class="calibre_9">4) "4"</p><p class="calibre_9">另外还有一个命令与ZINTERSTORE命令的用法一样，名为ZUNIONSTORE，它的作用是计算集合间的并集，这里不再赘述。</p><p class="calibre_9"><span class="bold">注　释</span></p><p id="filepos211603" class="calibre_9"><a href="index_split_015.html#filepos94941"><span class="calibre7"><span class="calibre_2">[1]. 即“由WordPress 驱动”。WordPress 是一个开源的博客程序，用户可以借其通过简单的配置搭建一个博客或内容管理系统。</span></span></a></p><p id="filepos211882" class="calibre_9"><a href="index_split_015.html#filepos96985"><span class="calibre7"><span class="calibre_2">[2]. Redis 的作者考虑过让字符串类型键支持超过 512 MB 大小的数据，未来的版本也可能会放宽这一限制，但无论如何，考虑到Redis的数据是使用内存存储的，512 MB 的限制已经非常宽松了。</span></span></a></p><p id="filepos212245" class="calibre_9"><a href="index_split_015.html#filepos105507"><span class="calibre7"><span class="calibre_2">[3]. 竞态条件是指一个系统或者进程的输出，依赖于不受控制的事件的出现顺序或者出现时机。</span></span></a></p><p id="filepos212489" class="calibre_9"><a href="index_split_015.html#filepos106100"><span class="calibre7"><span class="calibre_2">[4]. 原子操作取“原子”的“不可拆分”的意思，原子操作是最小的执行单位，不会在执行的过程中被其他命令插入打断。</span></span></a></p><p id="filepos212769" class="calibre_9"><a href="index_split_015.html#filepos108108"><span class="calibre7"><span class="calibre_2">[5]. 这个键名只是参考命名，实际应用中可以使用任何容易理解的名称。</span></span></a></p><p id="filepos212983" class="calibre_9"><a href="index_split_015.html#filepos109060"><span class="calibre7"><span class="calibre_2">[6]. MessagePack 和 JSON 一样可以将对象序列化成字符串，但其性能更高，序列化后的结果占用空间更小，序列化后的结果是二进制格式。MessagePack的项目地址是http://msgpack.org。</span></span></a></p><p id="filepos213328" class="calibre_9"><a href="index_split_016.html#filepos123001"><span class="calibre7"><span class="calibre_2">[7]. http://twitter.github.com/bootstrap。</span></span></a></p><p id="filepos213490" class="calibre_9"><a href="index_split_016.html#filepos126914"><span class="calibre7"><span class="calibre_2">[8]. 即Object-Relational Mapping（对象关系映射）。</span></span></a></p><p id="filepos213669" class="calibre_9"><a href="index_split_016.html#filepos129510"><span class="calibre7"><span class="calibre_2">[9]. 并不是所有命令都是如此，比如SET命令可以覆盖已经存在的键而不论原来键是什么类型。</span></span></a></p><p id="filepos213910" class="calibre_9"><a href="index_split_016.html#filepos132482"><span class="calibre7"><span class="calibre_2">[10]. HSETNX 中的“NX”表示“if Not eXists”（如果不存在）。</span></span></a></p><p id="filepos214105" class="calibre_9"><a href="index_split_017.html#filepos157351"><span class="calibre7"><span class="calibre_2">[11]. 4.5 节中还会详细介绍这个概念。</span></span></a></p><p id="filepos214273" class="calibre_9"><a href="index_split_018.html#filepos179980"><span class="calibre7"><span class="calibre_2">[12]. 集合类型键中元素是无序的，图3-18中为了便于读者阅读将元素按照大小顺序进行了排列。</span></span></a></p><p id="filepos214516" class="calibre_9"><a href="index_split_018.html#filepos185383"><span class="calibre7"><span class="calibre_2">[13]. 如果你亲自跟着输入了命令可能会发现得到的结果与书中的结果并不相同，这是正常现象，见后文描述。</span></span></a></p><p id="filepos214779" class="calibre_9"><a href="#filepos203461"><span class="calibre7"><span class="calibre_2">[14]. Unix 时间指UTC 时间1970 年1 月1 日0 时0 分0 秒起至现在的总秒数（不包括闰秒）。为什么是1970 年呢？因为Unix在1970年左右诞生。</span></span></a></p><div class="mbp_pagebreak" id="calibre_pb_19"></div>
</body></html>
