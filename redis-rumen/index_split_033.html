<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Redis入门指南（第2版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<blockquote id="filepos396232" class="calibre_11"><a href="index_split_000.html#filepos18521"><span class="calibre2"><span class="bold"><span class="calibre_2">6.1 概览</span></span></span></a></blockquote><p class="calibre_14">4.2.2 节实现了访问频率限制功能，可以限制一个 IP 地址在 1 分钟内最多只能访问100次：</p><p class="calibre_9">$isKeyExists = EXISTS rate.limiting:$IP</p><p class="calibre_9">if $isKeyExists is 1</p><blockquote class="calibre_13">$times =INCR rate.limiting:$IP</blockquote><blockquote class="calibre_13">if $times &gt; 100</blockquote><blockquote class="calibre_13">print 访问频率超过了限制，请稍后再试。</blockquote><blockquote class="calibre_13">exit</blockquote><p class="calibre_9">else</p><blockquote class="calibre_13">MULTIr</blockquote><blockquote class="calibre_13">INCRrate.limiting:$IP</blockquote><blockquote class="calibre_13">EXPIRE$keyName, 60</blockquote><blockquote class="calibre_13">EXEC</blockquote><p class="calibre_9">当时提到上面的代码会出现竞态条件，解决方法是用WATCH命令检测rate.limiting:$IP键的变动，但是这样做比较麻烦，而且还需要判断事务是否因为键被改动而没有执行。除此之外这段代码在不使用管道的情况下最多要向Redis请求5条命令，在网络传输上会浪费很多时间。</p><p class="calibre_9">我们这时最希望的就是Redis直接提供一个“RATELIMITING”命令用来实现访问频率限制功能，这个命令只需要我们提供键名、时间限制和在时间限制内最多访问的次数三个参数就可以直接返回访问频率是否超限。就像这样。</p><p class="calibre_9">if RATELIMITING rate.limiting:$IP, 60, 100</p><blockquote class="calibre_13">print 访问频率超过了限制，请稍后再试。</blockquote><p class="calibre_9">else</p><blockquote class="calibre_13"># 没有超限，显示博客内容</blockquote><p class="calibre_9">这种方式不仅代码简单、没有竞态条件（Redis的命令都是原子的），而且减少了通过网络发送和接收命令的传输开销。然而可惜的是 Redis 并没有提供这个命令，不过我们可以使用Redis脚本功能自己定义新的命令。</p><p id="filepos398805" class="calibre_6"><a href="index_split_000.html#filepos18714"><span class="calibre6"><span class="bold"><span class="calibre_2">6.1.1 脚本介绍</span></span></span></a></p><p class="calibre_14">Redis在2.6版推出了脚本功能，允许开发者使用Lua语言编写脚本传到Redis中执行。在Lua脚本中可以调用大部分的Redis命令，也就是说可以将6.1节中的第一段代码改写成Lua脚本后发送给Redis执行。使用脚本的好处如下。</p><p class="calibre_9">（1）减少网络开销：6.1节中的第一段代码最多需要向Redis发送5次请求，而使用脚本功能完成同样的操作只需要发送一个请求即可，减少了网络往返时延。</p><p class="calibre_9">（2）原子操作：Redis 会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说在编写脚本的过程中无需担心会出现竞态条件，也就无需使用事务。事务可以完成的所有功能都可以用脚本来实现。</p><p class="calibre_9">（3）复用：客户端发送的脚本会永久存储在 Redis 中，这就意味着其他客户端（可以是其他语言开发的项目）可以复用这一脚本而不需要使用代码完成同样的逻辑。</p><p id="filepos400100" class="calibre_6"><a href="index_split_000.html#filepos18922"><span class="calibre6"><span class="bold"><span class="calibre_2">6.1.2 实例：访问频率限制</span></span></span></a></p><p class="calibre_14">因为无需考虑事务，使用Redis脚本实现访问频率限制非常简单。Lua代码如下：</p><p class="calibre_9">local times = redis.call('incr', KEYS[1])</p><p class="calibre_9">if times == 1 then</p><blockquote class="calibre_13">-- KEYS[1]键刚创建，所以为其设置生存时间</blockquote><blockquote class="calibre_13">redis.call('expire', KEYS[1], ARGV[1])</blockquote><p class="calibre_9">end</p><p class="calibre_9">if times &gt; tonumber(ARGV[2]) then</p><blockquote class="calibre_13">return 0</blockquote><p class="calibre_9">end</p><p class="calibre_9">return 1</p><p class="calibre_9">这段代码实现的功能与我们之前所做的类似，不过简洁了很多，即使不了解Lua语言也能猜出大概的意思。如果有的地方看不懂也没关系，6.2节会专门介绍Lua的语法和调用Redis命令的方法。</p><p class="calibre_9">那么，如何测试这个脚本呢？首先把这段代码存为ratelimiting.lua，然后在命名行中输入：</p><p class="calibre_9">$<img src="images/00119.jpg" class="calibre_67"/>/path/to/ratelimiting.lua <img src="images/00121.jpg" class="calibre_68"/></p><p class="calibre_9">其中--eval参数是告诉redis-cli读取并运行后面的Lua脚本，<img src="images/00124.jpg" class="calibre_69"/>是 ratelimiting.lua 文件的位置，后面跟着的是传给 Lua 脚本的参数。其中“,”前的rate. limiting:127.0.0.1是要操作的键，可以在脚本中使用 KEYS[1]获取，“,”后面的10和3是参数，在脚本中能够使用ARGV[1]和ARGV[2]获得。结合脚本的内容可知这行命令的作用就是将访问频率限制为每10秒最多3次，所以在终端中不断地运行此命令会发现当访问频率在10秒内小于或等于3次时返回1，否则返回0。</p><p class="calibre_9">注意 上面的命令中“,”两边的空格不能省略，否则会出错。</p><p class="calibre_9">对于KEYS和ARGV两个变量会在6.3节中详细介绍，在下一节中我们会专门介绍Lua的语法。</p><div class="mbp_pagebreak" id="calibre_pb_33"></div>
</body></html>
