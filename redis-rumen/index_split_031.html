<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Redis入门指南（第2版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<blockquote id="filepos369605" class="calibre_11"><a href="index_split_000.html#filepos17452"><span class="calibre2"><span class="bold"><span class="calibre_2">5.4 Node.js与Redis</span></span></span></a></blockquote><p class="calibre_14">Redis官方推荐的Node.js的Redis客户端可以选择的有node_redis<sup class="calibre3"><small id="filepos369888" class="calibre4"><a href="#filepos393987"><span class="calibre5"><span class="calibre_2">[7]</span></span></a></small></sup> 和ioredis<sup class="calibre3"><small id="filepos370002" class="calibre4"><a href="#filepos394148"><span class="calibre5"><span class="calibre_2">[8]</span></span></a></small></sup> ，相比而言前者发布时间较早，而后者的功能则更加丰富一些。从接口来看两者的使用方法大同小异，本文将以ioredis为例讲解。</p><p id="filepos370274" class="calibre_6"><a href="index_split_000.html#filepos17639"><span class="calibre6"><span class="bold"><span class="calibre_2">5.4.1 安装</span></span></span></a></p><p class="calibre_14">使用npm install ioredis命令安装最新版本的ioredis。</p><p id="filepos370521" class="calibre_6"><a href="index_split_000.html#filepos17832"><span class="calibre6"><span class="bold"><span class="calibre_2">5.4.2 使用方法</span></span></span></a></p><p class="calibre_14">首先加载ioredis模块：</p><p class="calibre_9">var Redis = require('ioredis');</p><p class="calibre_9">下面的代码将创建一个默认连接到地址127.0.0.1，端口6379的Redis连接：</p><p class="calibre_9">var redis = new Redis();</p><p class="calibre_9">也可以显式地指定需要连接的地址：</p><p class="calibre_9">var redis = new Redis(6379, '127.0.0.1');</p><p class="calibre_9">由于Node.js的异步特性，在处理返回值的时候与其他客户端差别较大。还是以GET/SET命令为例：</p><p class="calibre_9">redis.set('foo', 'bar', function () {</p><blockquote class="calibre_13">//此时 SET 命令执行完并返回结果，</blockquote><blockquote class="calibre_13">//因为这里并不关心 SET命令的结果，所以我们省略了回调函数的形参。</blockquote><blockquote class="calibre_13">redis.get('foo', function (error, fooValue) {</blockquote><blockquote class="calibre_13">//error 参数存储了命令执行时返回的错误信息，如果没有错误则返回 null。</blockquote><blockquote class="calibre_13">//回调函数的第二个参数存储的是命令执行的结果</blockquote><blockquote class="calibre_13">console.log(fooValue); // 'bar'</blockquote><blockquote class="calibre_13">});</blockquote><p class="calibre_9">});</p><p class="calibre_9">使用ioredis执行命令时需要传入回调函数（callback function）来获得返回值，当命令执行完返回结果后ioredis会调用该函数，并将命令的错误信息作为第一个参数、返回值作为第二个参数传递给该函数。同时ioredis还支持Promise形式的异步处理方式，如果省略最后一个回调函数，命令语句会返回一个Promise值，如：</p><p class="calibre_9">redis.get('foo').then(function (fooValue) {</p><blockquote class="calibre_13">//fooValue 即为键值</blockquote><p class="calibre_9">});</p><p class="calibre_9">关于Node.js的异步模型的介绍超出了本书的范围，有兴趣的读者可以访问Node.js的官网<sup class="calibre3"><small id="filepos373143" class="calibre4"><a href="#filepos394303"><span class="calibre5"><span class="calibre_2">[9]</span></span></a></small></sup> 了解更多信息。</p><p class="calibre_9">Node.js的异步模型使得通过ioredis调用Redis命令的表现与Redis的底层管道协议十分相似：调用命令函数时（如redis.set()）并不会等待Redis返回命令执行结果，而是直接继续执行下一条语句，所以在Node.js中通过异步模型就能实现与管道类似的效果。上面的例子中我们并不需要SET命令的返回值，只要保证SET命令在GET命令前发出即可，所以完全不用等待SET命令返回结果后再执行GET命令。因此上面的代码可以改写成：</p><p class="calibre_9">//不需要返回值时可以省略回调函数</p><p class="calibre_9">redis.set('foo', 'bar');</p><p class="calibre_9">redis.get('foo', function (error, fooValue) {</p><blockquote class="calibre_13">console.log(fooValue); // 'bar'</blockquote><p class="calibre_9">});</p><p class="calibre_9">不过由于SET和GET并未真正使用Redis的管道协议发送，所以当有多个客户端同时向 Redis 发送命令时，上例中的两个命令之间可能会被插入其他命令，换句话说，GET命令得到的值未必是“bar”。</p><p class="calibre_9">虽然Node.js的异步特性给我们带来了相对更高的性能，然而另一方面使用Redis实现某个功能时我们经常需要读写若干个键，而且很多情况下都会依赖之前命令的返回结果。这时就会出现嵌套多重回调函数的情况，影响代码可读性。就像这样：</p><p class="calibre_9">redis.get('people:2:home', function (error, home) {</p><blockquote class="calibre_13">redis.hget('locations', home, function (error, address) {</blockquote><blockquote class="calibre_13">redis.exists('address:' + address, function (error, addressExists) {</blockquote><blockquote class="calibre_13">if (addressExists) {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">console.log('地址存在。');</blockquote></blockquote><blockquote class="calibre_13">} else {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">redis.exists('backup.address:' + address, function (error, backupAddress Exists) {</blockquote></blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">if (backupAddressExists) {</blockquote></blockquote><blockquote class="calibre_4"><blockquote class="calibre_4"><blockquote class="calibre_13">console.log('备用地址存在。');</blockquote></blockquote></blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">} else {</blockquote></blockquote><blockquote class="calibre_4"><blockquote class="calibre_4"><blockquote class="calibre_13">console.log('地址不存在。');</blockquote></blockquote></blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">}</blockquote></blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">});</blockquote></blockquote><blockquote class="calibre_13">}</blockquote><blockquote class="calibre_13">});</blockquote><blockquote class="calibre_13">});</blockquote><p class="calibre_9">});</p><p class="calibre_9">上面的代码并不是极端的情况，相反在实际开发中经常会遇到这种多层嵌套。为了减少嵌套，可以考虑使用 Async<sup class="calibre3"><small id="filepos376809" class="calibre4"><a href="#filepos394444"><span class="calibre5"><span class="calibre_2">[10]</span></span></a></small></sup> 、Step<sup class="calibre3"><small id="filepos376921" class="calibre4"><a href="#filepos394600"><span class="calibre5"><span class="calibre_2">[11]</span></span></a></small></sup> 等第三方模块。如上面的代码可以稍微修改后使用Async重写为：</p><p class="calibre_9">async.waterfall([</p><blockquote class="calibre_13">function (callback) {</blockquote><blockquote class="calibre_13">redis.get('people:2:home', callback);</blockquote><blockquote class="calibre_13">},</blockquote><blockquote class="calibre_13">function (home, callback) {</blockquote><blockquote class="calibre_13">redis.hget('locations', home, callback);</blockquote><blockquote class="calibre_13">},</blockquote><blockquote class="calibre_13">function (address, callback) {</blockquote><blockquote class="calibre_13">async.parallel([</blockquote><blockquote class="calibre_13">function (callback) {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">redis.exists('address:' + address, callback);</blockquote></blockquote><blockquote class="calibre_13">},</blockquote><blockquote class="calibre_13">function (callback) {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">redis.exists('backup.address:' + address, callback);</blockquote></blockquote><blockquote class="calibre_13">},</blockquote><blockquote class="calibre_13">], function (err, results) {</blockquote><blockquote class="calibre_13">if (results[0]) {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">console.log('地址存在。');</blockquote></blockquote><blockquote class="calibre_13">} else if (results[1]) {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">console.log('备用地址存在。');</blockquote></blockquote><blockquote class="calibre_13">} else {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">console.log('地址不存在。');</blockquote></blockquote><blockquote class="calibre_13">}</blockquote><blockquote class="calibre_13">});</blockquote><blockquote class="calibre_13">}</blockquote><p class="calibre_9">]);</p><p class="calibre_9">另外，可以使用co<sup class="calibre3"><small id="filepos379426" class="calibre4"><a href="#filepos394759"><span class="calibre5"><span class="calibre_2">[12]</span></span></a></small></sup> 模块借助ES6的Generator特性来将ioredis的返回结果“串行化”：</p><p class="calibre_9">var co = require('co');</p><p class="calibre_9">co(function* () {</p><blockquote class="calibre_13">var result = yield redis.get('foo');</blockquote><blockquote class="calibre_13">return result;</blockquote><p class="calibre_9">}).then(function (fooValue) {</p><blockquote class="calibre_13">console.log(fooValue);</blockquote><p class="calibre_9">});</p><p id="filepos380122" class="calibre_6"><a href="index_split_000.html#filepos18025"><span class="calibre6"><span class="bold"><span class="calibre_2">5.4.3 简便用法</span></span></span></a></p><p class="calibre_14">1．HMSET/HGETALL</p><p class="calibre_9">ioredis同样支持在HMSET命令中使用对象作参数（对象的属性值只能是字符串），相应的HGETALL命令会返回一个对象。</p><p class="calibre_9">2．事务</p><p class="calibre_9">事务的用法如下：</p><p class="calibre_9">var multi = redis.multi();</p><p class="calibre_9">multi.set('foo', 'bar');</p><p class="calibre_9">multi.sadd('set', 'a');</p><p class="calibre_9">mulit.exec(function (err, replies) {</p><blockquote class="calibre_13">//replies 是一个数组，依次存放事务队列中命令的结果</blockquote><blockquote class="calibre_13">console.log(replies);</blockquote><p class="calibre_9">});</p><p class="calibre_9">或者使用链式调用：</p><p class="calibre_9">redis.multi()</p><blockquote class="calibre_13">.set('foo', 'bar')</blockquote><blockquote class="calibre_13">.sadd('set', 'a')</blockquote><blockquote class="calibre_13">.exec(function (err, replies) {</blockquote><blockquote class="calibre_13">console.log(replies);</blockquote><blockquote class="calibre_13">});</blockquote><p class="calibre_9">3．“发布/订阅”模式</p><p class="calibre_9">Node.js 使用事件的方式实现“发布/订阅”模式。现在创建两个连接分别充当发布者和订阅者：</p><p class="calibre_9">var pub = new Redis();</p><p class="calibre_9">var sub = new Redis();</p><p class="calibre_9">然后让sub订阅chat频道并在订阅成功后发送一条消息：</p><p class="calibre_9">sub.subscribe('chat', function () {</p><blockquote class="calibre_13">pub.publish('chat', 'hi!');</blockquote><p class="calibre_9">});</p><p class="calibre_9">定义当接收到消息时要执行的回调函数：</p><p class="calibre_9">sub.on('message', function (channel, message) {</p><blockquote class="calibre_13">console.log('收到' + channel + '频道的消息：' + message);</blockquote><p class="calibre_9">});</p><p class="calibre_9">运行后可以看到打印的结果：</p><p class="calibre_9">$ node testpubsub.js</p><p class="calibre_9">收到chat频道的消息：'hi!'</p><p class="calibre_9">补充知识 在 ioredis 中建立连接的过程也是异步的，执行 redis = new Redis()后连接并没有立即建立完成。在连接建立完成前执行的命令会被加入到离线任务队列中，当连接建立成功后ioredis会按照加入的顺序依次执行离线任务队列中的命令。</p><p id="filepos383394" class="calibre_6"><a href="index_split_000.html#filepos18229"><span class="calibre6"><span class="bold"><span class="calibre_2">5.4.4 实践：IP地址查询</span></span></span></a></p><p class="calibre_14">很多场合下网站都需要根据访客的IP地址判断访客所在地。假设我们有一个地名和IP地址段的对应表<sup class="calibre3"><small id="filepos383727" class="calibre4"><a href="#filepos394908"><span class="calibre5"><span class="calibre_2">[13]</span></span></a></small></sup> ：</p><p class="calibre_9">上海: 202.127.0.0 ~ 202.127.4.255</p><p class="calibre_9">北京: 122.200.64.0 ~ 122.207.255.255</p><p class="calibre_9">如果用户的IP地址为122.202.2.0，我们就能根据这个表知道他的地址位于北京。Redis可以使用一个有序集合类型的键来存储这个表。</p><p class="calibre_9">首先将表中的IP地址转换成十进制数字：</p><p class="calibre_9">上海: 3397320704 ~ 3397321983</p><p class="calibre_9">北京: 2059943936 ~ 2060451839</p><p class="calibre_9">然后使用有序集合类型记录这个表。方式为每个地点存储两条数据：一条的元素值是地点名，分数是该地点对应的最大IP地址。另一条是“*”加上地点名，分数是该地点对应的最小IP地址，如图5-9所示。</p><p class="calibre_"><img src="images/00116.jpg" class="calibre_66"/>
</p><p class="calibre_10">图5-9 使用有序集合键存储地点和相应IP范围的存储结构</p><p class="calibre_9">在查找某个IP地址属于哪个地点时先将该IP地址转换成10进制数字，然后在有序集合中找到大于该数字的最小的一个元素，如果该元素不是以“*”开头则表示找到了，如果是则表示数据库中并未记录该IP地址对应的地名。</p><p class="calibre_9">如我们想找到“122.202.2.0”的所在地，首先将其转换成数字“2060059136”，然后在有序集合中找到第一个大于它的分数为“2060451839”，对应的元素值为“北京”，不是以“*”开头，所以该地址的所在地是北京。</p><p class="calibre_9">下面介绍使用Node.js实现这一过程。首先将表转换成CSV格式并存为ip.csv：</p><p class="calibre_9">上海,202.127.0.0,202.127.4.255</p><p class="calibre_9">北京,122.200.64.0,122.207.255.255</p><p class="calibre_9">而后使用node-csv模块<sup class="calibre3"><small id="filepos386029" class="calibre4"><a href="#filepos395093"><span class="calibre5"><span class="calibre_2">[14]</span></span></a></small></sup> 加载该csv文件：</p><p class="calibre_9">var fs = require('fs');</p><p class="calibre_9">var csv = require('csv');</p><p class="calibre_9">csv.parse(fs.readFileSync('ip.csv', 'utf8'), function (err, records) {</p><blockquote class="calibre_13">records.forEach(function (record) {</blockquote><blockquote class="calibre_13">importIP(record);</blockquote><blockquote class="calibre_13">});</blockquote><p class="calibre_9">});</p><p class="calibre_9">读取每行数据时node-csv-parser模块都会调用importIP回调函数。该函数实现如下：</p><p class="calibre_9">var Redis = require('redis');</p><p class="calibre_9">var redis = new Redis();</p><p class="calibre_9">//将 IP 地址数据加入 Redis</p><p class="calibre_9">//输入格式："['上海', '202.127.0.0', '202.127.4.255']"</p><p class="calibre_9">function importIP (data) {</p><blockquote class="calibre_13">var location = data[0];</blockquote><blockquote class="calibre_13">var minIP = convertIPtoNumber(data[1]);</blockquote><blockquote class="calibre_13">var maxIP = convertIPtoNumber(data[2]);</blockquote><blockquote class="calibre_13">//将数据加入到有序集合中，键名为'ip'</blockquote><blockquote class="calibre_13">redis.zadd('ip', minIP, '*' + location, maxIP, location);</blockquote><p class="calibre_9">}</p><p class="calibre_9">其中convertIPtoNumber函数用来将IP地址转换成十进制数字，</p><p class="calibre_9">//将 IP 地址转换成 10 进制数字</p><p class="calibre_9">//convertIPtoNumber('127.0.0.1') =&gt; 2130706433</p><p class="calibre_9">function convertIPtoNumber(ip) {</p><blockquote class="calibre_13">var result = '';</blockquote><blockquote class="calibre_13">ip.split('.').forEach(function (item) {</blockquote><blockquote class="calibre_13">item = ~~item;</blockquote><blockquote class="calibre_13">item = item.toString(2);</blockquote><blockquote class="calibre_13">item = pad(item, 8);</blockquote><blockquote class="calibre_13">result += item;</blockquote><blockquote class="calibre_13">});</blockquote><blockquote class="calibre_13">return parseInt(result, 2);</blockquote><p class="calibre_9">}</p><p class="calibre_9">pad函数用于将二进制数补全为8位：</p><p class="calibre_9">//在字符串前补'0'。</p><p class="calibre_9">//pad('11', 3) =&gt; '011'</p><p class="calibre_9">function pad(num, n) {</p><blockquote class="calibre_13">var len = num.length;</blockquote><blockquote class="calibre_13">while(len &lt; n) {</blockquote><blockquote class="calibre_13">num = '0' + num;</blockquote><blockquote class="calibre_13">len++;</blockquote><blockquote class="calibre_13">}</blockquote><blockquote class="calibre_13">return num;</blockquote><p class="calibre_9">}</p><p class="calibre_9">至此数据准备工作完成了，现在我们提供一个接口来供用户查询：</p><p class="calibre_9">var readline = require('readline');</p><p class="calibre_9">var rl = readline.createInterface({</p><blockquote class="calibre_13">input: process.stdin,</blockquote><blockquote class="calibre_13">output: process.stdout</blockquote><p class="calibre_9">});</p><p class="calibre_9">rl.setPrompt('IP&gt; ');</p><p class="calibre_9">rl.prompt();</p><p class="calibre_9">rl.on('line', function (line) {</p><blockquote class="calibre_13">ip = convertIPtoNumber(line);</blockquote><blockquote class="calibre_13">redis.zrangebyscore('ip', ip, '+inf', 'LIMIT', '0', '1', function (err,result) {</blockquote><blockquote class="calibre_13">if (!Array.isArray(result) || result.length === 0) {</blockquote><blockquote class="calibre_13">//该 IP 地址超出了数据库记录的最大 IP 地址</blockquote><blockquote class="calibre_13">console.log('No data.');</blockquote><blockquote class="calibre_13">} else {</blockquote><blockquote class="calibre_13">var location = result[0];</blockquote><blockquote class="calibre_13">if (location[0] === '*') {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">//该 IP 地址不属于任何一个 IP 地址段</blockquote></blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">console.log('No data.');</blockquote></blockquote><blockquote class="calibre_13">} else {</blockquote><blockquote class="calibre_4"><blockquote class="calibre_13">console.log(location);</blockquote></blockquote><blockquote class="calibre_13">}</blockquote><blockquote class="calibre_13">}</blockquote><blockquote class="calibre_13">rl.prompt();</blockquote><blockquote class="calibre_13">});</blockquote><p class="calibre_9">});</p><p class="calibre_9">运行后的结果如下：</p><p class="calibre_9">$ node ip_search.js</p><p class="calibre_9">IP&gt; 127.0.0.1</p><p class="calibre_9">No data.</p><p class="calibre_9">IP&gt; 122.202.23.34</p><p class="calibre_9">北京</p><p class="calibre_9">IP&gt; 202.127.3.3</p><p class="calibre_9">上海</p><p class="calibre_9">上面的代码的实际查找范围是一个半开半闭区间。如果想实现闭区间查找，读者可以在比对“*”时同时比较元素的分数和查找的IP地址是否相同。</p><p class="calibre_9"><span class="bold">注　释</span></p><p id="filepos392735" class="calibre_9"><a href="index_split_028.html#filepos319045"><span class="calibre7"><span class="calibre_2">[1]. https://github.com/nrk/predis</span></span></a></p><p id="filepos392888" class="calibre_9"><a href="index_split_028.html#filepos319160"><span class="calibre7"><span class="calibre_2">[2]. https://github.com/nicolasff/phpredis</span></span></a></p><p id="filepos393049" class="calibre_9"><a href="index_split_028.html#filepos320891"><span class="calibre7"><span class="calibre_2">[3]. PSR-0 标准由PHP Framework Interoperability Group 确定，其定义了PHP 命名空间与文件路径的对应关系。该标准的网址为https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md。</span></span></a></p><p id="filepos393389" class="calibre_9"><a href="index_split_029.html#filepos341749"><span class="calibre7"><span class="calibre_2">[4]. https://github.com/redis/redis-rb</span></span></a></p><p id="filepos393546" class="calibre_9"><a href="index_split_030.html#filepos354274"><span class="calibre7"><span class="calibre_2">[5]. https://github.com/andymccurdy/redis-py</span></span></a></p><p id="filepos393709" class="calibre_9"><a href="index_split_030.html#filepos368621"><span class="calibre7"><span class="calibre_2">[6]. ZINTERSTORE 命令的参数除了有序集合类型外还可以是集合类型，此时的集合类型会被作为分数为1的有序集合类型处理。</span></span></a></p><p id="filepos393987" class="calibre_9"><a href="#filepos369888"><span class="calibre7"><span class="calibre_2">[7]. https://github.com/mranney/node_redis</span></span></a></p><p id="filepos394148" class="calibre_9"><a href="#filepos370002"><span class="calibre7"><span class="calibre_2">[8]. https://github.com/luin/ioredis</span></span></a></p><p id="filepos394303" class="calibre_9"><a href="#filepos373143"><span class="calibre7"><span class="calibre_2">[9]. http://nodejs.org</span></span></a></p><p id="filepos394444" class="calibre_9"><a href="#filepos376809"><span class="calibre7"><span class="calibre_2">[10]. https://github.com/caolan/async</span></span></a></p><p id="filepos394600" class="calibre_9"><a href="#filepos376921"><span class="calibre7"><span class="calibre_2">[11]. https://github.com/creationix/step</span></span></a></p><p id="filepos394759" class="calibre_9"><a href="#filepos379426"><span class="calibre7"><span class="calibre_2">[12]. https://github.com/tj/co</span></span></a></p><p id="filepos394908" class="calibre_9"><a href="#filepos383727"><span class="calibre7"><span class="calibre_2">[13]. 该表只用于演示用途，其中的数据并不准确。</span></span></a></p><p id="filepos395093" class="calibre_9"><a href="#filepos386029"><span class="calibre7"><span class="calibre_2">[14]. 见https://github.com/wdavidw/node-csv。安装方法为 npm install csv。</span></span></a></p><div class="mbp_pagebreak" id="calibre_pb_31"></div>
</body></html>
