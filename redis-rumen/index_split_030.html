<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Redis入门指南（第2版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<blockquote id="filepos354018" class="calibre_11"><a href="index_split_000.html#filepos16505"><span class="calibre2"><span class="bold"><span class="calibre_2">5.3 Python与Redis</span></span></span></a></blockquote><p class="calibre_14">Redis官方推荐的Python客户端是redis-py<sup class="calibre3"><small id="filepos354274" class="calibre4"><a href="index_split_031.html#filepos393546"><span class="calibre5"><span class="calibre_2">[5]</span></span></a></small></sup> 。</p><p id="filepos354380" class="calibre_6"><a href="index_split_000.html#filepos16692"><span class="calibre6"><span class="bold"><span class="calibre_2">5.3.1 安装</span></span></span></a></p><p class="calibre_14">推荐使用 pip install redis 安装最新版本的 redis-py，也可以使用 easy_install：easy_ install redis。</p><p id="filepos354682" class="calibre_6"><a href="index_split_000.html#filepos16885"><span class="calibre6"><span class="bold"><span class="calibre_2">5.3.2 使用方法</span></span></span></a></p><p class="calibre_14">首先需要引入redis-py：</p><p class="calibre_9">import redis</p><p class="calibre_9">下面的代码将创建一个默认连接到地址127.0.0.1，端口6379的Redis连接：</p><p class="calibre_9">r = redis.StrictRedis()</p><p class="calibre_9">也可以显式地指定需要连接的地址：</p><p class="calibre_9">r = redis.StrictRedis(host='127.0.0.1', port=6379, db=0)</p><p class="calibre_9">使用起来很容易，这里以SET和GET命令作为示例：</p><p class="calibre_9">r.set('foo', 'bar') # True</p><p class="calibre_9">r.get('foo')　　# 'bar'</p><p id="filepos355605" class="calibre_6"><a href="index_split_000.html#filepos17078"><span class="calibre6"><span class="bold"><span class="calibre_2">5.3.3 简便用法</span></span></span></a></p><p class="calibre_14">1．HMSET/HGETALL</p><p class="calibre_9">HMSET支持将字典作为参数存储，同时HGETALL的返回值也是一个字典，搭配使用十分方便：</p><p class="calibre_9">r.hmset('dict', {'name': 'Bob'})</p><p class="calibre_9">people = r.hgetall('dict')</p><p class="calibre_9">print people # {'name': 'Bob'}</p><p class="calibre_9">2．事务和管道</p><p class="calibre_9">redis-py的事务使用方式如下：</p><p class="calibre_9">pipe = r.pipeline()</p><p class="calibre_9">pipe.set('foo', 'bar')</p><p class="calibre_9">pipe.get('foo')</p><p class="calibre_9">result = pipe.execute()</p><p class="calibre_9">print result # [True, 'bar']</p><p class="calibre_9">管道的使用方式和事务相同，只不过需要在创建时加上参数transaction=False：</p><p class="calibre_9">pipe = r.pipeline(transaction=False)</p><p class="calibre_9">事务和管道还支持链式调用：</p><p class="calibre_9">result = r.pipeline().set('foo', 'bar').get('foo').execute()</p><p class="calibre_9"># [True, 'bar']</p><p id="filepos357147" class="calibre_6"><a href="index_split_000.html#filepos17283"><span class="calibre6"><span class="bold"><span class="calibre_2">5.3.4 实践：在线的好友</span></span></span></a></p><p class="calibre_14">一般的社交网站上都可以看到用户在线的好友列表，如图5-4所示。在Redis中可以很容易地实现这个功能。</p><p class="calibre_"><img src="images/00104.jpg" class="calibre_61"/>
</p><p class="calibre_10">图5-4 某网站上用户的在线好友列表</p><p class="calibre_9">在线好友其实就是全站在线用户的集合和某个用户所有好友的集合取交集的结果。如果现在我们的网站就是使用集合类型键来存储用户的好友 ID 的，那么只需要一个存储在线用户列表的集合即可。如何判定一个用户是否在线呢？通常的方法是每当用户发送 HTTP 请求时都记录下请求发生的时间，所有指定时间内发送过请求的用户就算作在线用户。这段时间根据场景不同取值也不同，以10分钟为例：某个用户发送了一个HTTP请求，9分钟后系统仍然认为他是在线的，但到了第11分钟就不算作他在线了。</p><p class="calibre_9">在Redis中我们可以每隔10分钟就使用一个键来存储该10分钟内发送过请求的用户ID列表。如12点20分到12点29分的用户ID存储在active.users:2中，12点30分到12点39分的用户ID存储在active.users:3中，以此类推（注意每次调用SADD命令增加用户 ID 时需要同时设置键的生存时间在 50 分钟内以防止命名冲突）。这样需要获得当前在线用户只需要读取当前分钟数对应的键即可。不过这种方案会造成较大的误差，比如某个用户在29分访问了一个页面，他的ID被记录在active.users:2键中，而在30分时系统会读取active.users:3键来获取在线用户列表，即该用户的在线状态只持续了1分钟而不是预想的10分钟。</p><p class="calibre_9">这时就需要粒度更小的记录方案来解决这个问题。我们可以将原先每10分钟记录一个键改为每1分钟记录一个键，即在12点29分访问的用户的ID将会被记录在active.users:29中。而判断一个用户是否在最近10分钟在线只需要判断其在最近的10个集合键中是否出现过至少一次即可，这一过程可以通过SUNION命令实现。</p><p class="calibre_9">下面介绍使用Python来实现这一过程。我们这里使用了web.py框架，web.py是一个易于使用的Python 网站开发框架，可以通过 sudo pip install web.py 来安装它。</p><p class="calibre_9">代码如下：</p><p class="calibre_9"># -*- coding: utf-8 -*-</p><p class="calibre_9">import web</p><p class="calibre_9">import time</p><p class="calibre_9">import redis</p><p class="calibre_9">r = redis.StrictRedis()</p><p class="calibre_9">"""配置路由规则</p><p class="calibre_9">'/':　模拟用户的访问</p><p class="calibre_9">'/online':查看在线用户</p><p class="calibre_9">"""</p><p class="calibre_9">urls = (</p><blockquote class="calibre_13">'/', 'visit',</blockquote><blockquote class="calibre_13">'/online', 'online'</blockquote><p class="calibre_9">)</p><p class="calibre_9">app = web.application(urls, globals())</p><p class="calibre_9">"""返回当前时间对应的键名</p><p class="calibre_9">如28分对应的键名是active.users:28</p><p class="calibre_9">"""</p><p class="calibre_9">def time_to_key(current_time):</p><blockquote class="calibre_13">return 'active.users:' + time.strftime('%M', time.localtime(current_time))</blockquote><p class="calibre_9">"""返回最近 10 分钟的键名</p><p class="calibre_9">结果是列表类型</p><p class="calibre_9">"""</p><p class="calibre_9">def keys_in_last_10_minutes():</p><blockquote class="calibre_13">now = time.time()</blockquote><blockquote class="calibre_13">result = []</blockquote><blockquote class="calibre_13">for i in range(10):</blockquote><blockquote class="calibre_13">result.append(time_to_key(now - i * 60))</blockquote><blockquote class="calibre_13">return result</blockquote><p class="calibre_9">class visit:</p><blockquote class="calibre_13">""" 模拟用户访问</blockquote><blockquote class="calibre_13">将用户的 User agent 作为用户的 ID 加入到当前时间对应的键中</blockquote><blockquote class="calibre_13">"""</blockquote><blockquote class="calibre_13">def GET(self):</blockquote><blockquote class="calibre_13">user_id = web.ctx.env['HTTP_USER_AGENT']</blockquote><blockquote class="calibre_13">current_key = time_to_key(time.time())</blockquote><blockquote class="calibre_13">pipe = r.pipeline()</blockquote><blockquote class="calibre_13">pipe.sadd(current_key, user_id)</blockquote><blockquote class="calibre_13"># 设置键的生存时间为 10 分钟</blockquote><blockquote class="calibre_13">pipe.expire(current_key, 10 * 60)</blockquote><blockquote class="calibre_13">pipe.execute()</blockquote><blockquote class="calibre_13">return 'User:\t' + user_id + '\r\nKey:\t' + current_key</blockquote><p class="calibre_9">class online:</p><blockquote class="calibre_13">""" 查看当前在线的用户列表</blockquote><blockquote class="calibre_13">"""</blockquote><blockquote class="calibre_13">def GET(self):</blockquote><blockquote class="calibre_13">online_users = r.sunion(keys_in_last_10_minutes())</blockquote><blockquote class="calibre_13">result = ''</blockquote><blockquote class="calibre_13">for user in online_users:</blockquote><blockquote class="calibre_13">result += 'User agent:' + user + '\r\n'</blockquote><blockquote class="calibre_13">return result</blockquote><p class="calibre_9">if __name__ == "__main__":</p><blockquote class="calibre_13">app.run()</blockquote><p class="calibre_9">在代码中我们建立了两个页面。首先我们打开http://127.0.0.1:8080，该页面对应visit类，每次访问该页面都会将用户的浏览器User agent存储在记录当前分钟在线用户的键中，并将User agent和键名显示出来，如图5-5所示。</p><p class="calibre_"><img src="images/00106.jpg" class="calibre_62"/>
</p><p class="calibre_10">图5-5 使用Safari 访问http://127.0.0.1:8080</p><p class="calibre_9">从键名可知该次访问是在某时26分钟的时候发生的。然后使用另一个浏览器打开该页面，如图5-6所示。</p><p class="calibre_"><img src="images/00109.jpg" class="calibre_63"/>
</p><p class="calibre_10">图5-6 使用Firefox访问http://127.0.0.1:8080</p><p class="calibre_9">该次访问发生在29分钟。最后我们在37分钟时访问http://127.0.0.1:8080/online来查看当前在线用户列表，如图5-7所示。</p><p class="calibre_"><img src="images/00111.jpg" class="calibre_64"/>
</p><p class="calibre_10">图5-7 查看在线用户结果</p><p class="calibre_9">结果与预期一样，在线列表中只有在29分钟访问的用户。</p><p class="calibre_9">另一种方法：有序集合</p><p class="calibre_9">有时网站本来就要记录全站用户的最后访问时间（如图5-8所示），这时就可以直接利用此数据获得最后一次访问发生在10分钟内的用户列表（即在线用户）。</p><p class="calibre_"><img src="images/00114.jpg" class="calibre_65"/>
</p><p class="calibre_10">图5-8 Stack Overflow网站的个人资料页面记录了用户上次访问的时间</p><p class="calibre_9">我们使用一个有序集合来记录用户的最后访问时间，元素值为用户的ID，分数为最后一次访问的Unix时间。要获得最近10分钟访问过的用户列表可以使用ZRANGEBYSCORE命令：</p><p class="calibre_9">ten_minutes_ago = time.time() - 10 * 60</p><p class="calibre_9">online_users = r.zrangebyscore('last.seen', ten_minutes_ago, '+inf')</p><p class="calibre_9">那么如何获取在线的好友列表呢（与上一个例子一样，此时依然使用集合类型存储用户的好友列表）？最直接的方法就是将上面存储在线用户列表的online_users变量存入Redis的一个集合类型的键中然后和用户的好友列表取交集。然而这种方法需要在服务端和客户端之间传输数据，如果在线用户多的话会有较大的网络开销，而且这种方法也不能通过 Redis 的事务功能实现原子操作。为了解决这些问题，我们希望实现一个方法将ZRANGEBYSCORE命令的结果直接存入一个新键中而不返回到客户端。思路如下：</p><p class="calibre_9">有序集合只有 ZINTERSTORE 和 ZUNIONSTORE 两个命令支持直接将运算结果存入键中，然而这两个命令都不能实现我们要的操作。所以只能换种思路：既然没办法直接把有序集合中某一分数段的元素存入新键中，那何不干脆复制一个新建，并使用ZREMRANGEBYSCORE命令将我们不需要的分数段的元素删除？</p><p class="calibre_9">有了这一思路后下面的实现方法就很简单了，步骤如下。</p><p class="calibre_9">（1）复制一个 last.seen 键的副本 temp.last.seen，方法为 ZUNIONSTORE temp. last.seen 1 last.seen。在这里我们巧妙地借助了 ZUNIONSTORE 命令实现了对有序集合类型键的复制过程，即参加求并集操作的元素只有一个，结果自然就是它本身。</p><p class="calibre_9">（2）将不在线的用户（即 10 分钟以前的用户）删除。方法为 ZREMRANGEBYSCORE temp.last.seen 0 10分钟前的 Unix时间。</p><p class="calibre_9">（3）现在temp.last.seen键中存储的就是当前的在线用户了。我们将其和用户的好友列表做交集：ZINTERSTORE online.friends 2 temp.last.seen user:42:friends。这里我们以ID为42的用户举例，user:42:friends是存储其好友的集合类型键<sup class="calibre3"><small id="filepos368621" class="calibre4"><a href="index_split_031.html#filepos393709"><span class="calibre5"><span class="calibre_2">[6]</span></span></a></small></sup> 。</p><p class="calibre_9">（4）使用ZRANGE命令获取online.friends键的值。</p><p class="calibre_9">（5）收尾工作，删除temp.last.seen和online.friends键。因为temp.last. seen键可以被所有用户共用，所以可以根据情况将其缓存一段时间，在下次需要生成时先判断是否有该键，如果有则直接使用。</p><p class="calibre_9">以上5步需要使用事务或脚本实现以保证每个步骤的原子性。</p><p class="calibre_9">有的时候我们会使用有序集合键来存储用户的好友列表以记录成为好友的时间，此时第3步依然奏效。</p><p class="calibre_9">虽然以上的步骤有些复杂，但是实现起来并不难，有兴趣的读者可以自己完成。</p><div class="mbp_pagebreak" id="calibre_pb_30"></div>
</body></html>
