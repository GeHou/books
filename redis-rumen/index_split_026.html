<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Redis入门指南（第2版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<blockquote id="filepos293602" class="calibre_11"><a href="index_split_000.html#filepos13911"><span class="calibre2"><span class="bold"><span class="calibre_2">4.6 节省空间</span></span></span></a></blockquote><p class="calibre_14">Jim Gray<sup class="calibre3"><small id="filepos293818" class="calibre4"><a href="#filepos316994"><span class="calibre5"><span class="calibre_2">[6]</span></span></a></small></sup> 曾经说过：“内存是新的硬盘，硬盘是新的磁带。”内存的容量越来越大，价格也越来越便宜。2012年年底，亚马逊宣布即将发布一个拥有240GB内存的EC2实例，如果放到若干年前来看，这个容量就算是对于硬盘来说也是很大的了。即便如此，相比于硬盘而言，内存在今天仍然显得比较昂贵。而 Redis 是一个基于内存的数据库，所有的数据都存储在内存中，所以如何优化存储，减少内存空间占用对成本控制来说是一个非常重要的话题。</p><p id="filepos294492" class="calibre_6"><a href="index_split_000.html#filepos14113"><span class="calibre6"><span class="bold"><span class="calibre_2">4.6.1 精简键名和键值</span></span></span></a></p><p class="calibre_14">精简键名和键值是最直观的减少内存占用的方式，如将键名very.important.person:20改成VIP:20。当然精简键名一定要把握好尺度，不能单纯为了节约空间而使用不易理解的键名（比如将VIP:20修改为V:20，这样既不易维护，还容易造成命名冲突）。又比如一个存储用户性别的字符串类型键的取值是male和female，我们可以将其修改成m和f来为每条记录节约几个字节的空间（更好的方法是使用0和1来表示性别，稍后会详细介绍原因）<sup class="calibre3"><small id="filepos295245" class="calibre4"><a href="#filepos317267"><span class="calibre5"><span class="calibre_2">[7]</span></span></a></small></sup> 。</p><p id="filepos295351" class="calibre_6"><a href="index_split_000.html#filepos14312"><span class="calibre6"><span class="bold"><span class="calibre_2">4.6.2 内部编码优化</span></span></span></a></p><p class="calibre_14">有时候仅凭精简键名和键值所减少的空间并不足以满足需求，这时就需要根据 Redis内部编码规则来节省更多的空间。Redis为每种数据类型都提供了两种内部编码方式，以散列类型为例，散列类型是通过散列表实现的，这样就可以实现O(1)时间复杂度的查找、赋值操作，然而当键中元素很少的时候，O(1)的操作并不会比O(n)有明显的性能提高，所以这种情况下Redis会采用一种更为紧凑但性能稍差（获取元素的时间复杂度为O(n)）的内部编码方式。内部编码方式的选择对于开发者来说是透明的，Redis会根据实际情况自动调整。当键中元素变多时Redis会自动将该键的内部编码方式转换成散列表。如果想查看一个键的内部编码方式可以使用 OBJECT ENCODING 命令，例如：</p><p class="calibre_9">redis&gt; SET foo bar</p><p class="calibre_9">OK</p><p class="calibre_9">redis&gt; OBJECT ENCODING foo</p><p class="calibre_9">"raw"</p><p class="calibre_9">Redis的每个键值都是使用一个redisObject结构体保存的，redisObject的定义如下：</p><p class="calibre_9">typedef struct redisObject {</p><blockquote class="calibre_13">unsigned type:4;</blockquote><blockquote class="calibre_13">unsigned notused:2;　/* Not used */</blockquote><blockquote class="calibre_13">unsigned encoding:4;</blockquote><blockquote class="calibre_13">unsigned lru:22;　　/* lru time (relative to server.lruclock) */</blockquote><blockquote class="calibre_13">int refcount;</blockquote><blockquote class="calibre_13">void *ptr;</blockquote><p class="calibre_9">} robj;</p><p class="calibre_9">其中type字段表示的是键值的数据类型，取值可以是如下内容：</p><p class="calibre_9">#define REDIS_STRING 0</p><p class="calibre_9">#define REDIS_LIST 1</p><p class="calibre_9">#define REDIS_SET 2</p><p class="calibre_9">#define REDIS_ZSET 3</p><p class="calibre_9">#define REDIS_HASH 4</p><p class="calibre_9">encoding字段表示的就是Redis键值的内部编码方式，取值可以是：</p><p class="calibre_9">#define REDIS_ENCODING_RAW 0　/* Raw representation */</p><p class="calibre_9">#define REDIS_ENCODING_INT 1　/* Encoded as integer */</p><p class="calibre_9">#define REDIS_ENCODING_HT 2　/* Encoded as hash table */</p><p class="calibre_9">#define REDIS_ENCODING_ZIPMAP 3 /* Encoded as zipmap */</p><p class="calibre_9">#define REDIS_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */</p><p class="calibre_9">#define REDIS_ENCODING_ZIPLIST 5 /* Encoded as ziplist */</p><p class="calibre_9">#define REDIS_ENCODING_INTSET 6 /* Encoded as intset */</p><p class="calibre_9">#define REDIS_ENCODING_SKIPLIST 7 /* Encoded as skiplist */</p><p class="calibre_9">#define REDIS_ENCODING_EMBSTR 8 /* Embedded sds string encoding */</p><p class="calibre_9">各个数据类型可能采用的内部编码方式以及相应的 OBJECT ENCODING 命令执行结果如表4-2所示。</p><p class="calibre_10">表4-2 每个数据类型都可能采用两种内部编码方式之一来存储</p><p class="calibre_"><img src="images/00075.jpg" class="calibre_50"/>
</p><p class="calibre_9">下面针对每种数据类型分别介绍其内部编码规则及优化方式。</p><p class="calibre_9">1．字符串类型</p><p class="calibre_9">Redis使用一个sdshdr类型的变量来存储字符串，而redisObject的ptr字段指向的是该变量的地址。sdshdr的定义如下：</p><p class="calibre_9">struct sdshdr {</p><blockquote class="calibre_13">int len;</blockquote><blockquote class="calibre_13">int free;</blockquote><blockquote class="calibre_13">char buf[];</blockquote><p class="calibre_9">};</p><p class="calibre_9">其中len字段表示的是字符串的长度，free字段表示buf中的剩余空间，而buf字段存储的才是字符串的内容。</p><p class="calibre_9">所以当执行 SET key foobar时，存储键值需要占用的空间是 sizeof(redisObject) + sizeof(sdshdr) + strlen("foobar") = 30字节<sup class="calibre3"><small id="filepos300450" class="calibre4"><a href="#filepos317484"><span class="calibre5"><span class="calibre_2">[8]</span></span></a></small></sup> ，如图4-4所示。</p><p class="calibre_9">而当键值内容可以用一个64位有符号整数表示时，Redis会将键值转换成long类型来存储。如 SET key 123456，实际占用的空间是 sizeof(redisObject) = 16 字节，比存储"foobar"节省了一半的存储空间，如图4-5所示。</p><p class="calibre_"><img src="images/00078.jpg" class="calibre_51"/>
</p><p class="calibre_10">图4-4 字符串键值"foobar"使用 RAW 编码时的存储结构</p><p class="calibre_"><img src="images/00080.jpg" class="calibre_52"/>
</p><p class="calibre_10">图4-5 字符串键值"123456"的内存结构</p><p class="calibre_9">redisObject中的refcount字段存储的是该键值被引用数量，即一个键值可以被多个键引用。Redis启动后会预先建立10000个分别存储从0到9999这些数字的redisObject类型变量作为共享对象，如果要设置的字符串键值在这10000个数字内（如 SET key1 123）则可以直接引用共享对象而不用再建立一个 redisObject 了，也就是说存储键值占用的空间是0字节，如图4-6所示。</p><p class="calibre_9">由此可见，使用字符串类型键存储对象ID这种小数字是非常节省存储空间的，Redis只需存储键名和一个对共享对象的引用即可。</p><p class="calibre_"><img src="images/00083.jpg" class="calibre_53"/>
</p><p class="calibre_10">图4-6 当执行了 SET key1 123 和 SET key2 123 后，key1 和 key2两个键都直接引用了一个已经建立好的共享对象，节省了存储空间</p><p class="calibre_9">提示 当通过配置文件参数 maxmemory 设置了 Redis 可用的最大空间大小时，Redis不会使用共享对象，因为对于每一个键值都需要使用一个 redisObject 来记录其LRU信息。</p><p class="calibre_9">此外Redis 3.0新加入了 REDIS_ENCODING_EMBSTR 的字符串编码方式，该编码方式与REDIS_ENCODING_RAW类似，都是基于sdshdr实现的，只不过sdshdr的结构体与其对应的分配在同一块连续的内存空间中，如图4-7所示。</p><p class="calibre_"><img src="images/00086.jpg" class="calibre_54"/>
</p><p class="calibre_10">图4-7 字符串键值"foobar"使用 EMBSTR 编码时的存储结构</p><p class="calibre_9">使用REDIS_ENCODING_EMBSTR编码存储字符串后，不论是分配内存还是释放内存，所需要的操作都从两次减少为一次。而且由于内存连续，操作系统缓存可以更好地发挥作用。当键值内容不超过39字节时，Redis 会采用 REDIS_ENCODING_EMBSTR编码，同时当对使用REDIS_ENCODING_EMBSTR编码的键值进行任何修改操作时（如APPEND命令）， Redis会将其转换成REDIS_ENCODING_RAW编码。</p><p class="calibre_9">2．散列类型</p><p class="calibre_9">散列类型的内部编码方式可能是 REDIS_ENCODING_HT 或 REDIS_ENCODING_ZIPLIST<sup class="calibre3"><small id="filepos303841" class="calibre4"><a href="#filepos317664"><span class="calibre5"><span class="calibre_2">[9]</span></span></a></small></sup> 。在配置文件中可以定义使用REDIS_ENCODING_ZIPLIST方式编码散列类型的时机：</p><p class="calibre_9">hash-max-ziplist-entries 512</p><p class="calibre_9">hash-max-ziplist-value 64</p><p class="calibre_9">当散列类型键的字段个数少于hash-max-ziplist-entries参数值且每个字段名和字段值的长度都小于 hash-max-ziplist-value 参数值（单位为字节）时，Redis 就会使用 REDIS_ ENCODING_ZIPLIST 来存储该键，否则就会使用 REDIS_ENCODING_HT。转换过程是透明的，每当键值变更后Redis都会自动判断是否满足条件来完成转换。</p><p class="calibre_9">REDIS_ENCODING_HT编码即散列表，可以实现O(1)时间复杂度的赋值取值等操作，其字段和字段值都是使用 redisObject 存储的，所以前面讲到的字符串类型键值的优化方法同样适用于散列类型键的字段和字段值。</p><p class="calibre_9">提示 Redis的键值对存储也是通过散列表实现的，与 REDIS_ENCODING_HT 编码方式类似，但键名并非使用 redisObject 存储，所以键名"123456"并不会比"abcdef"占用更少的空间。之所以不对键名进行优化是因为绝大多数情况下键名都不会是纯数字。</p><p class="calibre_9">补充知识 Redis 支持多数据库，每个数据库中的数据都是通过结构体 redisDb 存储的。redisDb的定义如下：</p><p class="calibre_9">typedef struct redisDb {</p><blockquote class="calibre_13">dict *dict;　　　　/* The keyspace for this DB */</blockquote><blockquote class="calibre_13">dict *expires;　　　/* Timeout of keys with a timeout set */</blockquote><blockquote class="calibre_13">dict *blocking_keys;　　/* Keys with clients waiting for data (BLPOP) */</blockquote><blockquote class="calibre_13">dict *ready_keys;　　/* Blocked keys that received a PUSH */</blockquote><blockquote class="calibre_13">dict *watched_keys;　　/* WATCHED keys for MULTI/EXEC CAS */</blockquote><blockquote class="calibre_13">int id;</blockquote><p class="calibre_9">} redisDb;</p><p class="calibre_9">dict类型就是散列表结构，expires存储的是数据的过期时间。当Redis启动时会根据配置文件中 databases参数指定的数量创建若干个 redisDb类型变量存储不同数据库中的数据。</p><p class="calibre_9">REDIS_ENCODING_ZIPLIST 编码类型是一种紧凑的编码格式，它牺牲了部分读取性能以换取极高的空间利用率，适合在元素较少时使用。该编码类型同样还在列表类型和有序集合类型中使用。REDIS_ENCODING_ZIPLIST 编码结构如图 4-8 所示，其中 zlbytes是 uint32_t类型，表示整个结构占用的空间。zltail也是 uint32_t类型，表示到最后一个元素的偏移，记录 zltail 使得程序可以直接定位到尾部元素而无需遍历整个结构，执行从尾部弹出（对列表类型而言）等操作时速度更快。zllen是uint16_t类型，存储的是元素的数量。zlend是一个单字节标识，标记结构的末尾，值永远是255。</p><p class="calibre_"><img src="images/00089.jpg" class="calibre_55"/>
</p><p class="calibre_10">图4-8 REDIS_ENCODING_ZIPLIST编码的内存结构</p><p class="calibre_9">在REDIS_ENCODING_ZIPLIST中每个元素由4个部分组成。</p><p class="calibre_9">第一个部分用来存储前一个元素的大小以实现倒序查找，当前一个元素的大小小于254字节时第一个部分占用1个字节，否则会占用5个字节。</p><p class="calibre_9">第二、三个部分分别是元素的编码类型和元素的大小，当元素的大小小于或等于 63个字节时，元素的编码类型是ZIP_STR_06B（即0&lt;&lt;6），同时第三个部分用6个二进制位来记录元素的长度，所以第二、三个部分总占用空间是1字节。当元素的大小大于63且小于或等于16383字节时，第二、三个部分总占用空间是2字节。当元素的大小大于16383字节时，第二、三个部分总占用空间是5字节。</p><p class="calibre_9">第四个部分是元素的实际内容，如果元素可以转换成数字的话Redis会使用相应的数字类型来存储以节省空间，并用第二、三个部分来表示数字的类型（int16_t、int32_t等）。</p><p class="calibre_9">使用REDIS_ENCODING_ZIPLIST编码存储散列类型时元素的排列方式是：元素1存储字段1，元素2存储字段值1，依次类推，如图4-9所示。</p><p class="calibre_9">例如，当执行命令 HSET hkey foo bar命令后，hkey键值的内存结构如图4-10所示。</p><p class="calibre_"><img src="images/00091.jpg" class="calibre_56"/>
</p><p class="calibre_10">图4-9 使用 REDIS_ENCODING_ZIPLIST编码存储散列类型的内存结构</p><p class="calibre_"><img src="images/00094.jpg" class="calibre_57"/>
</p><p class="calibre_10">图4-10 hkey键值的内存结构</p><p class="calibre_9">下次需要执行 HSET hkey foo anothervalue时Redis需要从头开始找到值为 foo的元素（查找时每次都会跳过一个元素以保证只查找字段名），找到后删除其下一个元素，并将新值anothervalue插入。删除和插入都需要移动后面的内存数据，而且查找操作也需要遍历才能完成，可想而知当散列键中数据多时性能将很低，所以不宜将 hash-max-ziplist-entries和hash-max-ziplist-value两个参数设置得很大。</p><p class="calibre_9">3．列表类型</p><p class="calibre_9">列表类型的内部编码方式可能是 REDIS_ENCODING_LINKEDLIST或 REDIS ENCODING_ZIPLIST。同样在配置文件中可以定义使用REDIS_ENCODING_ZIPLIST方式编码的时机：</p><p class="calibre_9">list-max-ziplist-entries 512</p><p class="calibre_9">list-max-ziplist-value 64</p><p class="calibre_9">具体转换方式和散列类型一样，这里不再赘述。</p><p class="calibre_9">REDIS_ENCODING_LINKEDLIST编码方式即双向链表，链表中的每个元素是用redis Object 存储的，所以此种编码方式下元素值的优化方法与字符串类型的键值相同。</p><p class="calibre_9">而使用 REDIS_ENCODING_ZIPLIST 编码方式时具体的表现和散列类型一样，由于REDIS_ENCODING_ZIPLIST 编码方式同样支持倒序访问，所以采用此种编码方式时获取两端的数据依然较快。</p><p class="calibre_9">Redis最新的开发版本新增了 REDIS_ENCODING_QUICKLIST编码方式，该编码方式是REDIS_ENCODING_LINKEDLIST和REDIS_ENCODING_ZIPLIST的结合，其原理是将一个长列表分成若干个以链表形式组织的 ziplist，从而达到减少空间占用的同时提升REDIS_ENCODING_ZIPLIST编码的性能的效果。</p><p class="calibre_9">4．集合类型</p><p class="calibre_9">集合类型的内部编码方式可能是 REDIS_ENCODING_HT 或 REDIS_ENCODING_INTSET。当集合中的所有元素都是整数且元素的个数小于配置文件中的set-max-intset-entries参数指定值（默认是512）时Redis会使用REDIS_ENCODING_INTSET编码存储该集合，否则会使用REDIS_ENCODING_HT来存储。</p><p class="calibre_9">REDIS_ENCODING_INTSET编码存储结构体intset的定义是：</p><p class="calibre_9">typedef struct intset {</p><blockquote class="calibre_13">uint32_t encoding;</blockquote><blockquote class="calibre_13">uint32_t length;</blockquote><blockquote class="calibre_13">int8_t contents[];</blockquote><p class="calibre_9">} intset;</p><p class="calibre_9">其中contents存储的就是集合中的元素值，根据encoding的不同，每个元素占用的字节大小不同。默认的encoding是INTSET_ENC_INT16（即2个字节），当新增加的整数元素无法使用 2 个字节表示时，Redis 会将该集合的 encoding 升级为 INTSET_ENC_INT32（即4个字节）并调整之前所有元素的位置和长度，同样集合的encoding还可升级为INTSET_ENC_INT64（即8个字节）。</p><p class="calibre_9">REDIS_ENCODING_INTSET编码以有序的方式存储元素（所以使用SMEMBERS命令获得的结果是有序的），使得可以使用二分算法查找元素。然而无论是添加还是删除元素， Redis 都需要调整后面元素的内存位置，所以当集合中的元素太多时性能较差。</p><p class="calibre_9">当新增加的元素不是整数或集合中的元素数量超过了set-max-intset-entries参数指定值时，Redis会自动将该集合的存储结构转换成REDIS_ENCODING_HT。</p><p class="calibre_9">注意 当集合的存储结构转换成 REDIS_ENCODING_HT 后，即使将集合中的所有非整数元素删除，Redis也不会自动将存储结构转换回 REDIS_ENCODING_INTSET。因为如果要支持自动回转，就意味着Redis在每次删除元素时都需要遍历集合中的键来判断是否可以转换回原来的编码，这会使得删除元素变成了时间复架度为O(n)的操作。</p><p class="calibre_9">5．有序集合类型</p><p class="calibre_9">有序集合类型的内部编码方式可能是 REDIS_ENCODING_SKIPLIST 或 REDIS_ENCODING_ZIPLIST。同样在配置文件中可以定义使用REDIS_ENCODING_ZIPLIST方式编码的时机：</p><p class="calibre_9">zset-max-ziplist-entries 128</p><p class="calibre_9">zset-max-ziplist-value 64</p><p class="calibre_9">具体规则和散列类型及列表类型一样，不再赘述。</p><p class="calibre_9">当编码方式是REDIS_ENCODING_SKIPLIST时，Redis使用散列表和跳跃列表（skip list）两种数据结构来存储有序集合类型键值，其中散列表用来存储元素值与元素分数的映射关系以实现O(1)时间复杂度的 ZSCORE 等命令。跳跃列表用来存储元素的分数及其到元素值的映射以实现排序的功能。Redis对跳跃列表的实现进行了几点修改，其中包括允许跳跃列表中的元素（即分数）相同，还有为跳跃链表每个节点增加了指向前一个元素的指针以实现倒序查找。</p><p class="calibre_9">采用此种编码方式时，元素值是使用 redisObject 存储的，所以可以使用字符串类型键值的优化方式优化元素值，而元素的分数是使用double类型存储的。</p><p class="calibre_9">使用REDIS_ENCODING_ZIPLIST编码时有序集合存储的方式按照“元素1的值，元素1的分数，元素2的值，元素2的分数”的顺序排列，并且分数是有序的。</p><p class="calibre_9"><span class="bold">注　释</span></p><p id="filepos315579" class="calibre_9"><a href="index_split_021.html#filepos224971"><span class="calibre7"><span class="calibre_2">[1]. 事务回滚是指将一个事务已经完成的对数据库的修改操作撤销。</span></span></a></p><p id="filepos315787" class="calibre_9"><a href="index_split_022.html#filepos248458"><span class="calibre7"><span class="calibre_2">[2]. 事实上Redis 并不会准确地将整个数据库中最久未被使用的键删除，而是每次从数据库中随机取 3 个键并删除这3个键中最久未被使用的键。删除过期时间最接近的键的实现方法也是这样。“3”这个数字可以通过Redis的配置文件中的maxmemory-samples参数设置。</span></span></a></p><p id="filepos316244" class="calibre_9"><a href="index_split_023.html#filepos252410"><span class="calibre7"><span class="calibre_2">[3]. 集合类型经常被用于存储对象的ID，很多情况下都是整数。所以Redis 对这种情况进行了特殊的优化，元素的排列是有序的。4.6节会详细介绍具体的原理。</span></span></a></p><p id="filepos316568" class="calibre_9"><a href="index_split_023.html#filepos270425"><span class="calibre7"><span class="calibre_2">[4]. 有一个例外是当键类型为有序集合且参考键为常量键名时容器大小为m而不是n。</span></span></a></p><p id="filepos316796" class="calibre_9"><a href="index_split_024.html#filepos288359"><span class="calibre7"><span class="calibre_2">[5]. 由于redis-cli 的限制我们无法在其中测试 UNSUBSCRIBE 命令。</span></span></a></p><p id="filepos316994" class="calibre_9"><a href="#filepos293818"><span class="calibre7"><span class="calibre_2">[6]. Jim Gray是1998年的图灵奖得主，在数据库（尤其是事务）方面做出过卓越的贡献。其于2007 年独自驾船在海上失踪。</span></span></a></p><p id="filepos317267" class="calibre_9"><a href="#filepos295245"><span class="calibre7"><span class="calibre_2">[7]. 3.2.4 节还介绍过使用字符串类型的位操作来存储性别，更加节约空间。</span></span></a></p><p id="filepos317484" class="calibre_9"><a href="#filepos300450"><span class="calibre7"><span class="calibre_2">[8]. 本节所说的字节数以64 位Linux系统为前提。</span></span></a></p><p id="filepos317664" class="calibre_9"><a href="#filepos303841"><span class="calibre7"><span class="calibre_2">[9]. 在Redis 2.4 及以前的版本中散列类型的键采用 REDIS_ENCODING_HT或 REDIS_ENCODING_ZIPMAP 的编码方式。</span></span></a></p><div class="mbp_pagebreak" id="calibre_pb_26"></div>
</body></html>
